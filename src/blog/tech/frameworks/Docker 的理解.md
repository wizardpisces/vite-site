# Docker 镜像

## 层次关系

Docker 镜像的层次关系原理基于联合文件系统（Union File System），这种文件系统允许多个文件系统层次叠加在一起，表现为一个单一的文件系统。Docker 利用这一特性来构建和管理镜像和容器。

### 联合文件系统（Union File System）

联合文件系统（如 AUFS、OverlayFS、btrfs 等）是 Docker 的核心技术之一。它允许多个目录（称为层）叠加在一起，使其看起来像一个单一的目录。每一层都是只读的，只有最顶层是可写的。

### Docker 镜像层次结构

Docker 镜像由多个只读层组成，每一层对应 Dockerfile 中的一条指令。这些层是增量的，即每一层只包含相对于前一层的变化。镜像层次结构的基本原理如下：

1. **基础镜像层**：这是镜像的最底层，通常是一个操作系统的基础镜像（如 `ubuntu`、`alpine`、`node` 等）。它提供了运行应用所需的基本环境。

2. **中间层**：每一条 Dockerfile 指令（如 `RUN`、`COPY`、`ADD` 等）都会创建一个新的层。每个中间层只包含相对于前一层的变化。例如，安装软件包、复制文件等。

3. **顶层**：这是镜像的最顶层，通常包含应用程序的代码和配置文件。

### 容器层次结构

当你启动一个容器时，Docker 会在镜像的基础上添加一个可写层，这个可写层称为容器层。容器层是唯一可写的层，所有对文件系统的修改（如创建新文件、修改现有文件等）都会发生在这一层。

### 分层存储的优点

1. **高效存储**：由于每一层是只读的，并且是增量的，Docker 可以通过共享相同的基础层来节省存储空间。例如，多个基于同一基础镜像的容器可以共享该基础镜像的层。

2. **快速构建**：构建镜像时，如果某一层已经存在且没有变化，Docker 可以直接重用该层，而不需要重新构建。这大大加快了镜像的构建速度。

3. **缓存机制**：Docker 使用缓存机制来加速镜像的构建和部署。如果某一层已经存在于缓存中，并且没有变化，Docker 可以直接从缓存中获取该层，而不需要重新执行指令。

### 示例：Docker 镜像和容器的层次关系

假设我们有如下的 Dockerfile：

```Dockerfile
# 使用官方的 Node.js 镜像作为基础镜像
FROM node:14

# 设置工作目录
WORKDIR /app

# 复制 package.json 和 package-lock.json 到工作目录
COPY package*.json ./

# 安装依赖
RUN npm install

# 复制应用程序代码到工作目录
COPY . .

# 暴露应用程序运行的端口
EXPOSE 3000

# 运行应用程序
CMD ["node", "app.js"]
```

构建镜像时，每一条指令都会创建一个新的层：

1. **基础镜像层**：`FROM node:14`
2. **工作目录层**：`WORKDIR /app`
3. **复制依赖文件层**：`COPY package*.json ./`
4. **安装依赖层**：`RUN npm install`
5. **复制应用程序代码层**：`COPY . .`
6. **暴露端口层**：`EXPOSE 3000`
7. **运行应用程序层**：`CMD ["node", "app.js"]`

当你运行容器时，Docker 会在这些只读层的基础上添加一个可写层。所有对文件系统的修改都会发生在这个可写层中。

### 联合文件系统（Union File System）

联合文件系统（Union File System）如何允许多个文件系统层次叠加在一起，表现为一个单一的文件系统。例子：

假设我们有三个不同的目录，每个目录代表一个文件系统层：

1. **Layer 1**：包含基本的操作系统文件
2. **Layer 2**：包含一些应用程序文件
3. **Layer 3**：包含用户的数据文件，容器运行时的**可写层**

#### 目录结构

- **Layer 1**（基础操作系统层）
  ```
  /bin
  /lib
  /etc
  ```

- **Layer 2**（应用程序层）
  ```
  /app
  /usr/local/bin
  ```

- **Layer 3**（用户数据层）
  ```
  /home/user
  /var/log
  ```

#### 叠加后的联合文件系统

当我们使用联合文件系统将这三个层叠加在一起时，它们会表现为一个单一的文件系统：

```
/bin
/lib
/etc
/app
/usr/local/bin
/home/user
/var/log
```

### 具体例子：Docker 镜像和容器

让我们将这个概念应用到 Docker 镜像和容器上：

1. **基础镜像（Layer 1）**：假设我们使用一个 Ubuntu 基础镜像，它包含了操作系统的基本文件。
   ```
   /bin
   /lib
   /etc
   ```

2. **应用程序层（Layer 2）**：我们在基础镜像上安装了一个应用程序，这会创建一个新的层。
   ```
   /app
   /usr/local/bin
   ```

3. **用户数据层（Layer 3）**：容器运行时，用户在容器内创建或修改文件，这些变化会记录在一个可写层中。
   ```
   /home/user
   /var/log
   ```

#### 叠加后的文件系统

当我们启动容器时，Docker 会将这些层叠加在一起，表现为一个单一的文件系统：

```
/bin
/lib
/etc
/app
/usr/local/bin
/home/user
/var/log
```

用户在容器内看到的文件系统就像是一个完整的文件系统，尽管它实际上是由多个层叠加而成的。

## 写时复制

在写时复制机制（Copy-on-Write, CoW）下，可能存在两份 `/etc/config` 文件，一份在只读层（lower layer），一份在可写层（upper layer）。但是，从文件系统的视图来看，用户只会看到一份文件。具体来说，这样的设计是为了在保证只读层数据不变的同时允许用户修改文件。以下是更详细的解释：

### 联合文件系统视图

联合文件系统通过叠加多个层来形成一个合并视图，用户只会看到合并后的文件系统视图，而不是底层的具体实现。

### 文件叠加机制

1. **查找文件**：
   - 当用户访问 `/etc/config` 文件时，联合文件系统首先在可写层（upper layer）中查找。
   - 如果可写层中找不到该文件，则继续查找只读层（lower layer）。

2. **写时复制过程**：
   - 如果用户对 `/etc/config` 文件进行修改，并且该文件在只读层中存在（可写层中不存在），则联合文件系统会将该文件从只读层复制到可写层。
   - 所有的修改操作都会在可写层中的副本上进行。

### 确保数据完整性

这种机制确保了只读层的文件不会被直接修改，从而保持了其完整性。同时，用户对文件的修改操作仍然可以进行，只是这些修改会反映在可写层中。

### 实际示例

假设有一个联合文件系统，其中只读层和可写层的初始状态如下：

- **只读层（lower layer）**：
  ```
  /etc/config
  /var/log/app.log
  ```

- **可写层（upper layer）**：
  ```
  （初始为空）
  ```

当用户修改 `/etc/config` 文件时，文件系统执行以下步骤：

1. **查找**：
   - 在可写层中查找 `/etc/config`，未找到。
   - 在只读层中查找 `/etc/config`，找到该文件。

2. **复制**：
   - 将 `/etc/config` 文件从只读层复制到可写层。

3. **修改**：
   - 在可写层中的副本上进行修改。

修改后的文件系统层次结构如下：

- **只读层（lower layer）**：
  ```
  /etc/config
  /var/log/app.log
  ```

- **可写层（upper layer）**：
  ```
  /etc/config  （已被修改）
  ```

### 用户视图

用户通过文件系统看到的合并视图如下：

```
/etc/config  （已被修改）
/var/log/app.log  （未被修改）
```

从用户的角度来看，他们看到的只是一个文件系统，其中 `/etc/config` 文件已被修改，而不会意识到底层存在两份 `/etc/config` 文件。

### 具体应用

- **Docker容器**：Docker容器的文件系统利用联合文件系统叠加多个只读层（来自Docker镜像的各层）和一个可写层（容器的读写层）。容器启动后，所有对文件的修改都在可写层进行，而镜像层保持不变。

- **Linux Live CD**：Live CD系统通常是只读的，但用户可以在会话期间对文件进行修改。这些修改被写入到一个临时的可写层（如RAM），原始的CD内容不变。

### 总结

在联合文件系统中，通过写时复制机制，文件系统可以在只读层中保持文件的原始状态不变，同时允许用户对文件进行修改。这种机制在保持数据完整性和一致性的同时，提供了灵活的文件管理能力。虽然底层可能存在两份文件（原始和副本），但用户看到的是一个统一的、合并的文件系统视图。
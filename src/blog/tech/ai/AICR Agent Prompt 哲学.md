# AICR

使用 AI 进行 code diff review 的 Prompt 框架思考

## "弱规划，强框架"

```
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                          │
│  弱规划 (Weak Planning)                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  LLM 不负责决定:                                                 │   │
│  │  - "应该分几个阶段？"  → Prompt 已定义 (Stage 0-3)              │   │
│  │  - "评估哪些维度？"    → Prompt 已定义 (4个维度)                 │   │
│  │  - "什么算完成？"      → Prompt 已定义 (调用 comment_gitlab)     │   │
│  │                                                                  │   │
│  │  LLM 只决定:                                                     │   │
│  │  - "这个符号需要查吗？" (局部决策)                                │   │
│  │  - "这个问题 KEEP 还是 SKIP？" (局部决策)                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│  强框架 (Strong Framework)                                               │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Prompt 提供:                                                    │   │
│  │  - 固定的执行顺序 (Stage 0 → 1 → 2 → 3)                         │   │
│  │  - 标准化的评分体系 (0-10, 权重分配)                             │   │
│  │  - 严格的输出格式 (JSON schema)                                  │   │
│  │  - 明确的终止条件 (comment_gitlab)                               │   │
│  │  - 验证检查清单 (logical_chain_check, disproof_check)            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

## 让 Agent 自主决定会更好吗？

### 方案 A：强框架

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    方案 A: 强框架驱动                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  Prompt:                                                                │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  "你必须按 Stage 0-3 执行"                                       │   │
│  │  "你必须评估这 4 个维度"                                          │   │
│  │  "你必须输出这个 JSON 格式"                                       │   │
│  │  "你必须调用 comment_gitlab"                                     │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│  ✅ 优点:                                                               │
│  ├── 可预测: 每次执行流程一致                                           │
│  ├── 可控制: 输出格式标准化，易于后处理                                  │
│  ├── 可靠: 不会遗漏关键步骤 (框架强制)                                  │
│  ├── 快速: 不用花时间"规划"，直接执行                                   │
│  └── 低成本: token 消耗可预估                                           │
│                                                                          │
│  ❌ 缺点:                                                               │
│  ├── 僵化: 所有 MR 用同一套流程，不够灵活                                │
│  ├── 可能过度: 小改动也要跑完整流程                                     │
│  ├── 可能不足: 复杂改动可能需要更深入分析                                │
│  └── 无法适应: 特殊场景 (如安全审计) 无法自动调整策略                    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 方案 B：自主规划

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    方案 B: Agent 自主规划                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  Prompt:                                                                │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  "你是一个代码审查专家"                                           │   │
│  │  "请审查这个 MR，找出潜在问题"                                    │   │
│  │  "你可以使用 grep, read_file 等工具"                              │   │
│  │  "完成后提交审查结果"                                             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│  Agent 自己决定:                                                        │
│  ├── "这个 MR 看起来是 TH 站点的支付功能，我应该重点关注..."           │
│  ├── "这个改动涉及状态机，我需要追踪完整的状态转换..."                  │
│  ├── "这个文件有 200 行新增，我需要深入理解..."                        │
│  └── "我觉得分析够了，可以给出结论了"                                  │
│                                                                          │
│  ✅ 优点:                                                               │
│  ├── 灵活: 根据 MR 特点调整策略                                        │
│  ├── 深度: 复杂问题可以深挖                                            │
│  ├── 创造性: 可能发现框架遗漏的问题类型                                 │
│  └── 自适应: 不同类型 MR 不同处理方式                                   │
│                                                                          │
│  ❌ 缺点:                                                               │
│  ├── 不可预测: 每次执行流程可能不同                                     │
│  ├── 不可靠: 可能遗漏关键检查                                          │
│  ├── 慢: 需要先"规划"，消耗时间                                        │
│  ├── 贵: token 消耗不可预估，可能爆炸                                   │
│  ├── 可能死循环: 没有明确终止条件                                       │
│  └── 输出不一致: 难以后处理和对比                                       │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

## 核心权衡：可靠性 vs 灵活性

```
                    可靠性
                      ▲
                      │
                      │    ┌─────────────┐
                      │    │  强框架     │ ← 当前 AICR
                      │    │  (可预测)   │
                      │    └─────────────┘
                      │
                      │
                      │
                      │              ┌─────────────┐
                      │              │  自主规划   │
                      │              │  (不可预测) │
                      │              └─────────────┘
                      │
                      └────────────────────────────────► 灵活性
```

## 为什么 AICR 选择强框架？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    AICR 的业务场景约束                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  1. 批量处理需求                                                        │
│     ┌─────────────────────────────────────────────────────────────┐   │
│     │  每天可能有 100+ MR 需要审查                                  │   │
│     │  需要: 可预测的执行时间、成本、输出格式                        │   │
│     │  不能: 每个 MR 花费不确定的时间/token                         │   │
│     └─────────────────────────────────────────────────────────────┘   │
│                                                                          │
│  2. 结果可比性                                                          │
│     ┌─────────────────────────────────────────────────────────────┐   │
│     │  需要跟踪: "这个月发现了多少 Runtime 问题？"                   │   │
│     │  需要统计: "哪些文件/模块问题最多？"                           │   │
│     │  要求: 标准化的评分和分类                                      │   │
│     └─────────────────────────────────────────────────────────────┘   │
│                                                                          │
│  3. 集成到 CI/CD                                                        │
│     ┌─────────────────────────────────────────────────────────────┐   │
│     │  需要: 可解析的输出 (JSON)                                    │   │
│     │  需要: 可靠的终止条件 (不能卡住)                               │   │
│     │  需要: 确定性的行为 (同输入≈同输出)                            │   │
│     └─────────────────────────────────────────────────────────────┘   │
│                                                                          │
│  4. LLM 当前能力限制                                                    │
│     ┌─────────────────────────────────────────────────────────────┐   │
│     │  规划能力弱: 容易遗漏、容易偏题                                │   │
│     │  自我评估差: 不知道"分析够了吗"                                │   │
│     │  终止困难: 可能无限循环或过早结束                               │   │
│     │  → 强框架弥补这些弱点                                         │   │
│     └─────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

## 什么场景适合自主规划？

```
┌─────────────────────────────────────────────────────────────────────────┐
│               自主规划更适合的场景                                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  1. 一次性任务 (不需要批量处理)                                         │
│     └─ 例: "帮我 debug 这个问题"                                       │
│                                                                          │
│  2. 探索性任务 (不知道答案形式)                                         │
│     └─ 例: "分析这个系统的架构"                                        │
│                                                                          │
│  3. 高价值任务 (值得花更多成本)                                         │
│     └─ 例: 安全审计、架构评审                                          │
│                                                                          │
│  4. 需要创造性的任务                                                    │
│     └─ 例: "给我提一些改进建议"                                        │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

## 混合方案：在框架内保留灵活性

最佳实践是 **在强框架内嵌入有限的自主性**：

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    混合方案设计                                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  强框架部分 (不变):                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Stage 0 → Stage 1 → Stage 2 → Stage 3 → Submit                 │   │
│  │  固定的输出格式                                                   │   │
│  │  固定的终止条件                                                   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│  有限自主部分 (可调):                                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Stage 0 内部:                                                   │   │
│  │  ├── Agent 自己决定收集哪些上下文 ✓                              │   │
│  │  └── Agent 自己决定收集深度 ✓                                    │   │
│  │                                                                  │   │
│  │  Stage 1 内部:                                                   │   │
│  │  ├── Agent 自己判断文件重要性 ✓                                  │   │
│  │  └── Agent 自己决定分析优先级 ✓                                  │   │
│  │                                                                  │   │
│  │  Stage 3 内部:                                                   │   │
│  │  ├── Agent 自己决定验证方法 ✓                                    │   │
│  │  └── Agent 自己判断 KEEP/SKIP ✓                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│  这就是 AICR 的实际设计:                                                │
│  - 宏观流程固定 (可靠性)                                                │
│  - 微观决策自主 (灵活性)                                                │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

## 可视化对比

```
          完全自主                混合方案               完全框架
              │                     │                      │
              │                     │                      │
              ▼                     ▼                      ▼
    ┌─────────────────┐   ┌─────────────────┐    ┌─────────────────┐
    │ Agent 自己决定  │   │ 框架定宏观      │    │ 框架定一切      │
    │ - 做什么       │   │ Agent 定微观    │    │ Agent 执行      │
    │ - 怎么做       │   │                 │    │                 │
    │ - 何时结束     │   │ Stage 0-3 固定  │    │ 每步都预定义    │
    │                │   │ 内部决策自主    │    │ 无自主空间      │
    └─────────────────┘   └─────────────────┘    └─────────────────┘
           │                     │                      │
           │                     │                      │
    ┌──────┴──────┐       ┌──────┴──────┐        ┌──────┴──────┐
    │ 灵活但不可靠 │       │ 平衡        │        │ 可靠但僵化  │
    │ 如: ChatGPT │       │ 如: AICR    │        │ 如: Linter  │
    └─────────────┘       └─────────────┘        └─────────────┘
                                ▲
                                │
                            当前 AICR
```

## 结论

| 问题 | 回答 |
|------|------|
| 自主规划效果会更好吗？ | **不一定**，取决于场景 |
| AICR 为什么选择强框架？ | 批量处理、可预测性、可靠性需求 |
| 自主规划什么时候更好？ | 一次性、探索性、高价值任务 |
| 最佳实践是什么？ | **混合方案**：宏观框架 + 微观自主 |

**核心洞察**：

> 强框架不是因为 Agent 不够聪明，而是因为 **业务场景需要可预测性**。
> 
> 在框架内保留有限自主，是当前 LLM 能力边界下的务实选择。

当 LLM 的规划、自我评估、终止判断能力进一步提升后，可以逐渐放宽框架约束，给予更多自主权。**强框架是可靠性的保障**。
# 压缩稀疏行（Compressed Sparse Row, CSR）格式

## 压缩过程

### 生成`row_pointers`数组

`row_pointers`数组的生成是基于每行非零元素的累积数量来确定的。对于每一行，`row_pointers[i]`存储的是第i行第一个非零元素在`values`数组中的起始位置。具体步骤如下：

1. **初始化`row_pointers`数组**：
   - 创建一个长度为行数加一的数组`row_pointers`。额外的一个元素用于标记所有非零元素之后的位置。

2. **累计每行的非零元素数量**：
   - 遍历稀疏矩阵，每遇到一个非零元素就增加相应行的非零元素计数。

3. **填充`row_pointers`数组**：
   - 从第0行开始，累计每行的非零元素计数，并将其存储到`row_pointers`数组中。

### 具体例子

假设我们有以下稀疏矩阵A：

```
矩阵A：
[1, 0, 2, 0]
[0, 3, 0, 4]
[5, 0, 0, 0]
[0, 6, 0, 0]
```

我们生成`values`和`col_indices`数组如下：

- **values**：`[1, 2, 3, 4, 5, 6]`
- **col_indices**：`[0, 2, 1, 3, 0, 1]`

现在生成`row_pointers`数组的步骤如下：

1. **初始化`row_pointers`**：
   ```
   row_pointers = [0, 0, 0, 0, 0]
   ```

2. **累计每行的非零元素数量**：
   - 第0行有2个非零元素（1和2）
   - 第1行有2个非零元素（3和4）
   - 第2行有1个非零元素（5）
   - 第3行有1个非零元素（6）

3. **填充`row_pointers`数组**：
   - `row_pointers[0]` = 0 （第0行的非零元素起始于`values[0]`）
   - `row_pointers[1]` = `row_pointers[0]` + 第0行的非零元素数量 = 0 + 2 = 2 （第1行的非零元素起始于`values[2]`）
   - `row_pointers[2]` = `row_pointers[1]` + 第1行的非零元素数量 = 2 + 2 = 4 （第2行的非零元素起始于`values[4]`）
   - `row_pointers[3]` = `row_pointers[2]` + 第2行的非零元素数量 = 4 + 1 = 5 （第3行的非零元素起始于`values[5]`）
   - `row_pointers[4]` = `row_pointers[3]` + 第3行的非零元素数量 = 5 + 1 = 6 （这是所有非零元素之后的位置）

最终生成的`row_pointers`数组为：
```
row_pointers = [0, 2, 4, 5, 6]
```

## 还原过程

在还原稀疏矩阵时，`row_pointers`数组起到重要作用。它帮助我们确定每行非零元素在`values`和`col_indices`中的范围。具体步骤如下：

1. **初始化还原矩阵**：
   - 创建一个与原始矩阵A尺寸相同的零矩阵。

2. **遍历每一行的非零元素**：
   - 使用`row_pointers`数组确定每行的非零元素在`values`和`col_indices`中的起始和结束位置。
   - 将这些非零元素填充回零矩阵的对应位置。

### 具体还原步骤

假设我们要还原上面的矩阵A：

1. **初始化还原矩阵**：
   ```
   A_restored = [[0, 0, 0, 0],
                 [0, 0, 0, 0],
                 [0, 0, 0, 0],
                 [0, 0, 0, 0]]
   ```

2. **遍历每一行的非零元素**：
   - 第0行：`row_pointers[0] = 0`, `row_pointers[1] = 2`
     ```
     从values[0]到values[1]：
     A_restored[0, col_indices[0]] = values[0] -> A_restored[0, 0] = 1
     A_restored[0, col_indices[1]] = values[1] -> A_restored[0, 2] = 2
     ```

   - 第1行：`row_pointers[1] = 2`, `row_pointers[2] = 4`
     ```
     从values[2]到values[3]：
     A_restored[1, col_indices[2]] = values[2] -> A_restored[1, 1] = 3
     A_restored[1, col_indices[3]] = values[3] -> A_restored[1, 3] = 4
     ```

   - 第2行：`row_pointers[2] = 4`, `row_pointers[3] = 5`
     ```
     从values[4]到values[4]：
     A_restored[2, col_indices[4]] = values[4] -> A_restored[2, 0] = 5
     ```

   - 第3行：`row_pointers[3] = 5`, `row_pointers[4] = 6`
     ```
     从values[5]到values[5]：
     A_restored[3, col_indices[5]] = values[5] -> A_restored[3, 1] = 6
     ```

最终还原的矩阵为：
```
A_restored = [[1, 0, 2, 0],
              [0, 3, 0, 4],
              [5, 0, 0, 0],
              [0, 6, 0, 0]]
```

是的，除了压缩稀疏行（Compressed Sparse Row, CSR）格式外，还有其他几种常见的稀疏矩阵压缩方法。下面介绍几种常见的方法及其特点：

# 其他压缩方法
### 1. 压缩稀疏列（Compressed Sparse Column, CSC）

CSC格式与CSR格式类似，但它按列而不是按行存储非零元素。它使用三个数组来存储稀疏矩阵：

- **values**：存储非零元素。
- **row_indices**：存储每个非零元素的行索引。
- **col_pointers**：存储每列的非零元素在`values`数组中的起始位置。

#### 例子
对于矩阵A：
```
矩阵A：
[1, 0, 2, 0]
[0, 3, 0, 4]
[5, 0, 0, 0]
[0, 6, 0, 0]
```

- **values**：`[1, 5, 3, 6, 2, 4]`
- **row_indices**：`[0, 2, 1, 3, 0, 1]`
- **col_pointers**：`[0, 2, 4, 4, 6]`

### 2. 块稀疏行（Block Compressed Sparse Row, BCSR）

BCSR格式是CSR格式的扩展，通过将稀疏矩阵划分为固定大小的块来进行压缩。这种方法可以提高存储和计算的局部性，从而提高性能。

#### 例子
对于矩阵A：
```
矩阵A：
[1, 0, 2, 0]
[0, 3, 0, 4]
[5, 0, 0, 0]
[0, 6, 0, 0]
```
可以划分为2x2的块：
```
[1, 0]
[0, 3]

[2, 0]
[0, 4]

[5, 0]
[0, 6]
```
- **values**：包含所有块中的非零元素。
- **block_row_ptr**：指示每个块行的起始位置。
- **block_col_ind**：指示每个块列的索引。

### 3. 稀疏对角（Diagonal, DIA）

DIA格式用于对角线为主的稀疏矩阵，通过存储矩阵的对角线来压缩数据。它使用两个数组：

- **values**：存储对角线元素。
- **offsets**：存储每条对角线的偏移。

#### 例子
对于矩阵A：
```
矩阵A：
[1, 0, 0, 0]
[0, 1, 0, 0]
[0, 0, 1, 0]
[0, 0, 0, 1]
```
- **values**：`[[1, 1, 1, 1]]`
- **offsets**：`[0]`

### 4. 协同存储格式（Coordinate List, COO）

COO格式通过存储非零元素的行索引、列索引和对应值来表示稀疏矩阵。它使用三个数组：

- **row_indices**：存储非零元素的行索引。
- **col_indices**：存储非零元素的列索引。
- **values**：存储非零元素的值。

#### 例子
对于矩阵A：
```
矩阵A：
[1, 0, 2, 0]
[0, 3, 0, 4]
[5, 0, 0, 0]
[0, 6, 0, 0]
```

- **row_indices**：`[0, 0, 1, 1, 2, 3]`
- **col_indices**：`[0, 2, 1, 3, 0, 1]`
- **values**：`[1, 2, 3, 4, 5, 6]`

### 5. 压缩稀疏块（Compressed Sparse Blocks, CSB）

CSB格式是一种块压缩格式，适用于具有局部密集块的稀疏矩阵。它将矩阵划分为小块，并仅存储非零块的信息。CSB格式在并行计算中表现良好。

#### 例子
假设矩阵A划分为2x2的块：

```
[1, 0] [2, 0]
[0, 3] [0, 4]
[5, 0] [0, 0]
[0, 6] [0, 0]
```
只存储含非零元素的块。

### 总结

不同的稀疏矩阵压缩方法适用于不同的应用场景和矩阵结构。选择合适的压缩方法可以大大提高存储效率和计算性能。

## 块稀疏行跟 压缩稀疏块 区别

### 块稀疏行（BCSR）

BCSR格式是CSR格式的扩展，通过将稀疏矩阵划分为固定大小的块来进行压缩。它在块级别上存储数据，从而提高存储和计算的局部性。

#### 例子

假设我们有以下稀疏矩阵A：

```
矩阵A：
[1, 0, 2, 0]
[0, 3, 0, 4]
[5, 0, 0, 0]
[0, 6, 0, 0]
```

我们将矩阵A划分为2x2的块：

```
[1, 0] [2, 0]
[0, 3] [0, 4]
[5, 0] [0, 0]
[0, 6] [0, 0]
```

BCSR格式会存储这些块中的非零元素及其索引：

- **values**：`[1, 0, 0, 3, 2, 0, 0, 4, 5, 0, 0, 6]`
- **block_row_ptr**：`[0, 2, 3]`（每个块行的起始位置）
- **block_col_ind**：`[0, 1, 0]`（每个块列的索引）

### 压缩稀疏块（CSB）

CSB格式通过将稀疏矩阵划分为大小相等的小块，并仅存储含有非零元素的块。它适用于矩阵具有局部密集块的情况，尤其是在并行计算中表现良好。

#### 例子

我们使用相同的矩阵A，并将其划分为2x2的块：

```
[1, 0] [2, 0]
[0, 3] [0, 4]
[5, 0] [0, 0]
[0, 6] [0, 0]
```

CSB格式会存储每个非零块及其位置：

- **values**：存储非零块的内容：
  ```
  values = [[1, 0, 0, 3],  # 第一块
            [2, 0, 0, 4],  # 第二块
            [5, 0, 0, 6]]  # 第三块
  ```

- **block_indices**：存储每个非零块的位置（块的行和列索引）：
  ```
  block_indices = [(0, 0), (0, 1), (1, 0)]
  ```

### 区别

1. **数据存储方式**：
   - **BCSR**：按固定大小的块存储，适用于较为均匀分布的稀疏矩阵。每行块的起始位置和列索引分别存储在`block_row_ptr`和`block_col_ind`中。
   - **CSB**：按包含非零元素的块存储，适用于具有局部密集块的稀疏矩阵。每个非零块的内容和位置分别存储在`values`和`block_indices`中。

2. **适用场景**：
   - **BCSR**：适用于较为均匀分布的稀疏矩阵，通过块级别的存储优化提高存储和计算的局部性。
   - **CSB**：适用于具有局部密集块的稀疏矩阵，在并行计算中表现良好，因为可以独立处理每个块。

3. **实现复杂度**：
   - **BCSR**：相对简单，因为只需处理固定大小的块。
   - **CSB**：相对复杂，因为需要动态确定每个非零块的位置和内容。

### 具体操作步骤

**还原BCSR矩阵**：

- 根据`block_row_ptr`和`block_col_ind`确定每个块的位置。
- 从`values`中提取每个块的内容，填充到原始矩阵中相应位置。

**还原CSB矩阵**：

- 根据`block_indices`确定每个非零块的位置。
- 从`values`中提取每个非零块的内容，填充到原始矩阵中相应位置。

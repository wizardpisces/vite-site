# 软件2.0

[原文](https://karpathy.medium.com/software-2-0-a64152b37c35)

概念：软件2.0通常指的是那些在其核心集成了机器学习模型的软件系统。这些系统的行为不仅仅是由传统的编程代码决定的，而是由数据驱动的模型生成的。

以下是对文章一些观点的理解
## 融合模块以求最优
Modules can meld into an optimal whole
>原文：普通软件通常被分解成多个模块，各个模块中间通过共有函数、API 或者端到端的方式通信。然而，对于软件2.0，如果一开始2个相交互的模块是独立训练的，我们之后也很容易在整个系统中进行反向传播。想想看，如果你的浏览器可以自动设计底层指令，从而提高加载页面的速度；或者说你导入的计算机视觉库（比如 OpenCV）可以根据你的特定数据，自动调整行为；

理解：
软件2.0指的是那些利用机器学习模型作为其核心组件的软件系统。关键特点是它能够通过收集数据和反向传播来持续学习和自我优化。这种方式**使得软件能够更加智能和适应性强，因为它不再是静态的代码集合，而是一个能够随着时间和数据的积累而变得更加高效的动态系统。**

举例：

1. **浏览器自动设计底层指令：**
   在这个例子中，我们可以想象一个浏览器，它不仅仅是静态地执行预定义的指令来加载页面。相反，它具备了通过机器学习来优化这些指令的能力。例如，浏览器可以监控用户的上网习惯、页面加载时间、系统资源使用情况等数据，并且使用这些数据来训练一个模型，这个模型能够预测并调整底层的网络请求、资源分配策略，甚至是JavaScript引擎的工作方式，以提高页面加载的速度。这种优化是动态进行的，能够适应不同用户的使用环境和习惯。

2. **计算机视觉库自动调整行为：**
   在另一个例子中，传统的计算机视觉库，比如OpenCV，提供了一系列预定义的算法和函数来处理图像和视频数据。在软件2.0的情况下，这些库可以进一步智能化。假设你正在使用这样的库来进行面部识别，库本身可以包含一个或多个机器学习模型，这些模型可以根据你提供的特定数据（比如，你的应用中的用户面部图像）自动调整其内部参数。这样，面部识别的准确性不仅仅取决于通用算法，还取决于它如何通过学习特定的数据集来自我优化。

## 对抗样本导致软件 2.0 异常
>原文：软件2.0的奇怪特性也在不断出现。比如，对抗样本和攻击样本的存在，使得软件2.0的不可解释性问题变得更加突出。

理解：
对抗样本是经过特别设计的输入数据，它们对人类来说可能看起来和正常数据没有区别，但是能够欺骗机器学习模型，使其做出错误的预测或分类。这些情况突出了软件2.0的不可解释性问题，因为即使是模型的开发者也很难完全理解或解释为什么模型会被这些对抗样本所欺骗。这种不可解释性不仅挑战了模型的可靠性，也给安全性带来了风险，尤其是在那些对精确性和可靠性有着极高要求的应用场景中。

例如：

1. **自动驾驶汽车：**
   在自动驾驶汽车中，使用了大量的机器学习模型来处理视觉识别任务，例如识别交通标志。一个对抗样本的例子可能是一个轻微修改过的停车标志，虽然对于人类来说这个标志看起来没有任何问题，但是修改可能会导致自动驾驶系统无法正确识别这个标志，从而可能忽略停车指令，引发安全问题。

2. **面部识别系统：**
   在安全性要求高的面部识别系统中，对抗样本可能是经过精心设计的图像或者是特定的化妆或配饰，这些对于人眼来说不会影响识别，但可能会导致面部识别系统无法正确识别或者将一个人错误地识别为另一个人。

## 理解 1.0 vs 2.0

### 软件 1.0

- **模块演化**
   - 初始：单一大型服务（单体架构）。
   - 演化：服务分解为小型、独立的模块，这些模块相互配合工作（微服务架构）。
- **设计哲学：** 基于规则的编程，开发者需要手动编写代码来明确规定软件的每一步行为。
- **开发方式：** 往往是水平式的，需要事先规划架构和未来可能的扩展点。
- **更新迭代：** 更新通常涉及整个系统的重新部署或至少是较大模块的重新部署。
- **可解释性：** 高，因为行为是由清晰的代码逻辑决定的。
- **示例：** 传统的ERP系统，银行交易系统等，这些系统都是具有固定逻辑和复杂业务规则的系统。

### 软件 2.0

- **模块演化** 
   - 初始：独立的专用模型完成各自的任务，然后将结果整合（如多个单独的模型串联处理任务）。
   - 演化：单个端到端模型直接处理整个任务，没有中间转换步骤（如一个模型同时处理语音识别、自然语言理解和语音合成）。
- **设计哲学：** 基于数据和学习的编程，软件通过对大量数据进行学习来自我优化和改进，而非仅仅依据预编程的规则。
- **开发方式：** 往往是垂直式的，能够从数据中自主学习并适应新任务，不需要开发者预见到每一种可能。
- **更新迭代：** 在很多情况下，模型可以通过持续学习实现自我更新而无需人为干预。
- **可解释性：** 相对较低，因为模型决策过程复杂且不总是透明的。
- **示例：** 机器学习驱动的推荐系统（如YouTube或Netflix的推荐算法），自然语言处理系统（如GPT-3），自动驾驶车辆。

软件1.0更倾向于模块化和微服务架构，其设计是为了解决特定的、已知的问题而构建的。而软件2.0则向着使用数据驱动的方法，通过端到端的模型自动学习解决问题，这常涉及人工智能和机器学习特别是深度学习领域。

## 水平跟垂直式开发

### 水平式开发（Software 1.0）

水平式开发通常指的是传统的软件开发过程，这里的"水平"可以类比于搭建房屋的每一层。这种方法的特点包括：

- **层次结构**：软件以层的形式构建，每一层依赖于下面的一层。比如，用户界面层依赖于业务逻辑层，而业务逻辑层则依赖于数据访问层。
- **模块化**：系统被分解为功能模块，每个模块负责特定的功能或服务。
- **规划先行**：在开发之前需要详尽的规划，了解系统所有层和模块如何相互作用。
- **硬编码**：逻辑是通过编写具体的代码指令来实现的，对于新的问题和需求通常需要开发人员手动进行修改和更新。

### 垂直式开发（Software 2.0）
垂直式开发则更多地与数据驱动的机器学习方法相联系，"垂直"可以类比于从基础设施一直向上生长的树木。这种方法的特点包括：

- **端到端学习**：任务从输入到输出通过一个端到端的系统来完成，没有必须人为编写的规则。
- **数据为中心**：系统主要通过分析和学习大量数据来获得知识和解决问题的能力。
- **动态适应**：系统可以不断从新的数据中学习，从而适应新的问题和场景。
- **自主性**：因为模型可以自我学习，所以对于未知问题的适应性强，这减少了人工编写代码的需要。

在机器学习（尤其是深度学习）中，垂直式的发展体现在从底层特征直接学习到高层的决策，而无需人类专家制定复杂的规则或者手动设计特征。

总体来说，水平式开发注重于开发者明确规划各个模块的交互和功能，而垂直式开发依赖于从数据中自动学习模式和规律，这样的系统通常能自适应未见过的数据或情况。

# Ilya 推荐的 30 篇
(30篇论文，就能掌握当今科技90%的知识！ILYA公布神级论文清单(上）)[https://mp.weixin.qq.com/s?__biz=Mzk0NzQzOTczOA%3D%3D&mid=2247507514&idx=3&sn=6f90564bb8a07f39d360aec1968e6b14&ref=openi.cn]
(下)[https://mp.weixin.qq.com/s?__biz=Mzk0NzQzOTczOA==&mid=2247507451&idx=1&sn=d586514585870f4e3205199a8f6f2f5f&chksm=c3744ceef403c5f883ea5a495e58764ffa57cbf7a7c5c0fa30b4493057f58ef288774b0768a4&scene=21#wechat_redirect]

# Reference
* 翻译 [颠覆式编程：软件2.0](https://zhuanlan.zhihu.com/p/366808383)
* [视频：大模型解决不了英伟达的难题，AI新范式必将出现：专访安克创新CEO阳萌](https://www.youtube.com/watch?v=kMBjzxKYWw4)
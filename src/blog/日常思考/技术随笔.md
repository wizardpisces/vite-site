
# 预处理

* 归一化：一种常见的图像预处理操作，它用于将图像的像素值归一化为均值为0、标准差为1的分布，或者只将数据收窄到 -1 ~ 1 之间。常用于 CNN 网络数据预处理
    * 加速训练：常用的激活函数如 Sigmoid 和 Tanh 在输入值较大或较小的区域会饱和，导致梯度接近或完全为零，从而使梯度下降变得非常缓慢或停滞。通过将像素值缩放到 -1 到 1 的范围，可以使输入值位于激活函数的线性区域，避免梯度饱和问题，提高网络的训练效果。
    * 模型稳定性：在优化算法中，例如梯度下降法，较大的梯度值可能导致参数更新过大，从而使优化过程不稳定甚至发散。通过将像素值缩放到 -1 到 1 的范围，可以将梯度控制在较小的范围内，提高优化算法的数值稳定性，使模型更容易收敛。
    * 数据分布一致性：将像素值缩放到 -1 到 1 的范围可以使不同图像之间的像素分布更加一致。这样做的目的是确保输入数据的统计特性在整个训练集上是相似的，从而提高模型的泛化能力。
    * 推广：Batch Normalization (BN) 层作用类似，但是应用在**训练阶段**，对每个小批量数据进行标准化

# 损失函数
## 交叉熵

* 熵：阿根廷 1/4概率打进决赛 ，1/2 概率获得冠军，1/8 获得冠军，则有 f(1/8) = f(1/2) + f(1/4)，f(x) := 信息量，推出可能的 f(x) := -log(x) （log 2为底单调上升，加负号才则单调向下）
* 交叉熵：KL 散度是一种用于衡量两个概率分布之间差异的度量，KL(P || Q) = Σ(P(i) * log(P(i) / Q(i)))，固定分布 P 的时候 KL 散度可以化简为交叉熵 KL(P || Q) = Σ(P(i) * log(P(i) / Q(i))) = -Σ(P(i) * log(Q(i))) = -H(P, Q)；可以很好的用于机器学习损失计算

### 问题
* 回归跟分类区别？
    * 分类例子：识别图片是猫还是狗
    * 回归例子：通过特征1-n预测房价
    * 思考：分类跟回归的区别是目标的 离散跟连续 区别？还是说输出的label之间是否有“距离度量”？
* 为什么交叉熵适合分类，而 MSE 适合回归?
    * 交叉熵
        * 概率解释性：交叉熵基于概率分布之间的差异进行度量，更适合分类问题，因为分类问题通常涉及对不同类别的概率分布进行建模和预测。
        * 梯度更强烈：相对于MSE，交叉熵的梯度更加陡峭，这可以加快模型的收敛速度。对于分类问题，更快的收敛速度可能是一个优势。
    * MES
        * 数学上的合理性：MSE 是对预测值与真实值的差异的平方进行度量，可以提供对预测误差的较为精确的度量。
        * 对异常值不敏感：平方差的计算使得 MSE 对异常值不敏感，因为平方操作会放大异常值的影响。这在某些回归问题中可能是有益的。

Reference
* [王木头学科学](https://www.youtube.com/@wkaing)
* https://zhuanlan.zhihu.com/p/104130889
* [回归与分类问题区别](https://cloud.tencent.com/developer/article/1604194)
# Transformer 

## positional encoding
位置编码的要求：选择正弦跟余弦组合编码
* 每个位置都有唯一的编码。
* 在不同长度的句子中，两个时间步之间的距离应该一致。
* 模型不受句子长短的影响，并且编码范围是有界的。（不会随着句子加长数字就无限增大）
* 必须是确定性的。

总结
* 问题及其解答：
    * 为什么没有直接使用 1,2,3...这种线性编码？
        * 原因：周期性模式在位置编码中的不同维度上呈现出不同的变化速度和周期（下面例子会说明）
            * 捕捉长距离依赖关系（线性模式也能做到，但是不够精细）
            * 提供更丰富的表示能力：较低频率的维度具有较长的周期，可以捕捉到大范围的序列结构，而较高频率的维度可以更细致地表示局部模式和短距离的依赖关系。
            * 避免过拟合：随着句子变长，这些值可能会变得特别大，并且我们的模型可能会遇到比训练时更长的句子
* 思考例子：
    * 第一个词编码为 [1,2,3]， 则位置可用向量 [秒，分，时]来表示；第二个词编码为 [4,5,6]， 则位置可用向量 [秒 + 1，分 + 1/60，时 + 1/360] 来表示
    * 周期：在一个词向量上会出现不同的周期变化，能同时追踪近距离跟远距离的词关系：秒针走一个周期 60 秒，分针走一步；分走一个周期 60 分， 时针+1；
    * 周期设定：通过设定 秒，分，时之间的周期关系（比如可以设定600秒，分针才走一步，则会拉上周期变化，追踪更远的词关系）

Reference
* [positional encoding blog](https://kazemnejad.com/blog/transformer_architecture_positional_encoding/)
* [positional encoding stackexchange + youtube](https://datascience.stackexchange.com/questions/51065/what-is-the-positional-encoding-in-the-transformer-model)

## self-attention

思考
* 多头注意力机制与卷积的多通道（channel）进行类比。多头注意力机制和卷积的多通道都涉及并行地学习不同的特征表示。它们都致力于提取输入数据的多样化特征，并捕捉输入中的不同模式和关联性。

Reference
* [self-attention](https://medium.com/@geetkal67/attention-networks-a-simple-way-to-understand-self-attention-f5fb363c736d)
* [multi-head attention in transformer](https://medium.com/@geetkal67/attention-networks-a-simple-way-to-understand-multi-head-attention-3bc3409c4312))


# one hot 编码
one hot编码，将离散的分类数据转换为神经网络等模型可以处理的向量表示。
```python
# 假设 text 中的字符集是由大小写字母和数字组成的，共有 62 个字符（例如，char_set = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"），则 self.char_set_len 的值为 62。对于每个字符 ch，它在字符集中的索引位置是唯一的，因此 i * self.char_set_len + self.char_set.index(ch) 的结果也是唯一的。
vector = np.zeros(self.max_captcha * self.char_set_len) # shape = [max_captcha*36]
for i, ch in enumerate(text):
    idx = i * self.char_set_len + self.char_set.index(ch) # idx = (0-(max_captcha-1))*36+(0-36)
    vector[idx] = 1
```
思考：如果是不定长编码，该如何改进?
## CRNN + CTC 解决变长文本识别

### CTC 如何计算预测序列跟目标序列的相识度？
1. 生成 time step 的预测概率（有 CRNN 模型输出），每个 time step 会有对类别的预测概率向量
2. 通过算法将所有可能路径的概率相加，并取对数（通常用于数值稳定性）得到最终的相似度分数。
[Reference](https://wandb.ai/authors/text-recognition-crnn-ctc/reports/Text-Recognition-With-CRNN-CTC-Network--VmlldzoxNTI5NDI)
# 深度学习编程范式
Tensorflow vs Pytorch（符号式与命令式程序）
命令式
* 更加灵活：原生语言的灵活性跟运行时断点
```python
    import numpy as np
    a = np.ones(10)
    b = np.ones(10) * 2
    c = b * a
    d = c + 1
```
对应符号式（DSL）：
* 节省内存：掌控全局的内存分析并优化
```python
    A = Variable('A')
    B = Variable('B')

    # 当执行 C = B * A 时，不会发生任何计算。相反，此操作会生成表示计算的计算图（也称为符号图）
    C = B * A 
    D = C + Constant(1)

    # compiles the function 并真正的执行计算结果
    f = compile(D) 
    d = f(A=np.ones(10), B=np.ones(10)*2)
```
符号图：![符号图](https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/prog_model/comp_graph.png)

类比：类似 react jsx命令式（直接难优化）模板跟 vue 的声明式（真正执行前能做各种运行时优化）模板？

[Reference blog](https://mxnet.apache.org/versions/1.9.1/api/architecture/program_model#:~:text=Symbolic%20Programs%20Tend%20to%20be,flow%20of%20a%20host%20language.)

# 机器学习分类的一点技巧
* 对数据进行分类
    * 有特征：直接通过已经有的分类进行绘制图
        * 先通过特征维度绘制图；例如：数据集仅包含两个分离相当明显的聚类。其中一个簇包含 Iris setosa，而另一个簇包含 Iris virginica 和 Iris versicolor；通过特征绘制出的图会分成明显2堆，其中一堆是交错2种类型 Iris
        * 如果没有明显的聚类，并且数据维度多，可以通过 PCA 等方式降维后再分
    * 无特征：则先通过 KMeans 能方式聚类，再通过有特征方式分析
# 尝试理解 ONNX （Open Neural Network Exchange）
* 是什么？ONNX = （模型本身 + 模型训练好的权重跟偏置）的一种更加抽象的表达
* 如何表示？使用预定义的 operator（描述输入与输出的关系，例如：add算子=  inputA + inputB = OutputC，可拓展）来描述模型，用向量描述训练好的参数
* 作用？实现不同深度学习框架和平台之间的模型互操作性
* 为什么 pytorch 在导出 ONNX 的时候需要传入一组输入？原因：
    * ONNX 并非像编译器一样彻底解析原模型的代码，记录所有控制流；而是不考虑控制流的静态图
    * 而是利用 pytorch trace 机制，将参数传入模型执行，并记录执行这组输入对应的计算图

# 深度学习中的 Epoch 和 Batch
1. Epoch 是什么？ 
一次 Epoch = 让所有数据通过模型正向+反向传播一次 = 一个完整的学习周期
2. Epoch 设置多少次合适？
无定论：
次数少会导致欠拟合；
次数多会导致过拟合；
3. 什么是 Batch？
Batch Size = 一次训练的样本数
每一次参数的更新所需要损失函数并不是由一个数据获得的，而是由一批数据加权得到的
4. Batch 的作用？
* 效率：利用矩阵计算加速（相对于单个去训练）
* 稳定性：平均每个数据样本的贡献，减少梯度的方差
* 多大合适：看情况，太小会导致训练太久；太大会导致内存受不了

Reference
* [epoch-vs-iterations-vs-batch-size](https://towardsdatascience.com/epoch-vs-iterations-vs-batch-size-4dfb9c7ce9c9)

# GPT 尝试
1. 代码尝试
    * 重构转换
        * 输入 js -> ts
    * 优化
        * 格式化代码
    * 创建
        * 创建插件（eslint）步骤：写测试用例 -> 输入 gpt -> 生成插件 -> 微调成型
            * 问题：自动生成的代码会比较繁琐或者隐藏逻辑问题，也不会去利用第三方的包的能力
            * 目前方案：需要 developer 找到更便捷的方式再去投喂给 gpt 生成更加合理简洁的代码
# 内存对齐
空间换时间？
优势：对齐可以加快 CPU 访问速度
劣势：会浪费空间
# 符号表 2023-3-6
1. wiki
符号表是一种用于语言翻译器（例如编译器和解释器）中的数据结构。在符号表中，程序源代码中的每个标识符都和它的声明或使用信息绑定在一起，比如其数据类型、作用域以及内存地址。
2. Example
[Symbol_table#Example](https://en.wikipedia.org/wiki/Symbol_table#Example)
* Go 编译器默认编译出来的程序会带有符号表和调试信息，一般来说 release 版本可以去除调试信息以减小二进制体积。
* ABI（Application binary interface）： 约定数据在二进制流上的排列，还有 calling convention 等方式便于不同语种交互
    * low-level, hardware-dependent  vs API（high-level, hardware-independent，human readable format）
3. 思考
有点类似 js 的 source-map？
# 风控引擎优化 2023-3-2
1. 什么是风控？

> input：风控参数，参数权重，参数组合判定逻辑

> output：reject/pass

2. 为什么需要优化？
> 风控的判定效率越高，对下游真实业务的阻塞也就越小

3. 如何做？
* 参数获取：参数的获取可能渠道获取（redis/kafka/db 等）
    * 并行
    * 参数筛选排序拉取：根据业务数据使用权重，推迟小概率使用的参数拉取
* 逻辑组合
    * 时序调整（调整逻辑执行先后顺序）
    * 剪枝（编译阶段无效判定逻辑消除）

# 扩容机制 2023-3-2

需要处理好扩容跟收缩

1. 栈空间（或者堆空间）策略
    * 分段机制
        * 旧秩序的延续
        * 保留旧有数据空间，申请新空间存放溢出数据，通过链表连接各片段
    * 连续机制
        * 新秩序替换旧秩序
        * 触发扩容会申请更大的空间（2倍？类似 golang 切片的动态扩容机制），把旧空间数据搬到新空间，并释放掉旧空间
    * 优化：延迟归还给操作系统，自己管理内存的伸缩，例如：golang 的 goroutine [go内存管理](https://dreamgoing.github.io/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html)

2. 服务能力
    * 横向：拓展更多集群服务
        * 流量降低时会触发收缩
    * 纵向：提升单体服务能力

# AOP（面向切面编程） 2023-3-1

* 解释：运行时动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。
    * 例子：js 的装饰器
    * 场景：使用 AOP 将其从核心关注点中分离出来（实际是对执行过程进行代理重写）
        * Node.js 日志log
        * 埋点、数据上报
        * 性能分析、统计函数执行时间
        * 给ajax请求动态添加参数、动态改变函数参数
        * 分离表单请求和验证
        * 防抖与节流...
* 遭遇：golang 垃圾回收 [三色标记法与读写屏障](https://zhuanlan.zhihu.com/p/352475559)
* 摘要：AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。[什么是面向切面编程 AOP？](https://www.zhihu.com/question/24863332)

# 逃逸分析
解释：在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法——分析在程序的哪些地方可以访问到指针。它涉及到指针分析和形状分析。

遭遇：在了解 golang reflect 的过程 “用于获取接口值 reflect.Value 的函数 reflect.ValueOf 实现也非常简单，在该函数中我们先调用了 reflect.escapes 保证当前值**逃逸到堆上**，然后通过 reflect.unpackEface 从接口中获取 reflect.Value 结构体；”

逃逸基础
* 不同于jvm的运行时逃逸分析，golang的逃逸分析是在编译期完成的。
* Golang的逃逸分析只针对指针。一个值引用变量如果没有被取址，那么它永远不可能逃逸。
* C 或者 C++ 是手动分配到栈或者堆上，后面是否会加上运行时逃逸分析

功能
* 逃逸分析辅助编译器优化编译结果
    * 将堆分配转化为栈分配。如果某个对象在子程序中被分配，并且指向该对象的指针永远不会逃逸，该对象就可以在分配在栈上，而不是在堆上。在有垃圾收集的语言中，这种优化可以降低垃圾收集器运行的频率。

[编译器优化的场景](https://www.eet-china.com/mp/a51348.html)

## Reference
* [golang 逃逸分析详解](https://zhuanlan.zhihu.com/p/91559562)
* [golang 反射原理](https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#43-%E5%8F%8D%E5%B0%84)

# 文章精读之设计原则/模式
## 设计原则：SOLID原则
* Single Responsibility Principle 单一原则；
    - 一种Class只负责一类事情
* Open/Closed Principle 开闭原则；
    - 允许在不改变已有代码前提下添加新功能
* Liskov Substitution Principle 里氏替换原则；
    - 不要从可实例化的父类中继承（方法），而是要使用基于抽象类和接口的继承。
* Interface Segregation Principle 接口隔离原则；
    - Clients should not be forced to depend upon interfaces that they do not use. 对于非必须的参数做可选配置，精简接口，简化使用
* Dependency Inversion Principle 依赖反转原则
    - High-level modules should not depend on low-level modules. 
    - Both should depend on abstractions.Abstractions should not depend upon details. Details should depend on abstractions.
    - 降低耦合，方便重构跟扩展
## 设计模式
### Creational Patterns
* Fatory Method
* SingleTon
### Behavioral Patterns
* Strategy
* Observer
* Iterator
### Structural Patterns
* Adapter
* Decorator
* Proxy
## 设计原则 vs 设计模式
* 简洁理解：设计模式（语言相关）是对设计原则（语言独立）的实现
* 长文理解
    - Design principles provide high level guidelines to design better software applications. They do not provide implementation guidelines and are not bound to any programming language.
    - Design Pattern provides low-level solutions related to implementation, of commonly occurring object-oriented problems. In other words, design pattern suggests a specific implementation for the specific object-oriented programming problem.

## Reference
* https://github.com/ryanmcdermott/clean-code-javascript#solid
* https://www.tutorialsteacher.com/articles/difference-between-design-principle-and-design-pattern
* https://github.com/sohamkamani/javascript-design-patterns-for-humans#behavioral-design-patterns
* https://github.com/lpxxn/rust-design-pattern

# 关于继承
谈到继承就会说到“类”，“类”封装的是数据，是对同一类数据实体以及其处理方法的抽象。

* 目的：
    1. 代码复用
    2. 多态（同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。实现方式：覆盖，重载；某种程度也算代码复用？）
        * 覆盖：指子类重新定义父类方法，例如js的prototype
        * 重载：多个同名但参数不同的方法，例如 Rust 函数模板

* 继承方式：
    1. 正统：C++,java
    2. 模拟：js原型链
    3. 无：Rust trait 组合实现多态
        思考：Rust 的编程建模模式更像是组合（Composition） 而不是继承（Inheritance）？有点类似 Vue3 选择 Composition-API 代替 Class-Option？

多态图解：![多态](https://pic1.zhimg.com/80/v2-6f26625afb5174fa5228e817cd68a7db_1440w.jpg?source=1940ef5c)

[图来源](https://www.zhihu.com/question/66038192/answer/1898435232)
### Reference
* [为什么Rust没有继承？](https://fengliang.io/RustWHY/design_choices/why_not_inheritance.html)
* https://www.runoob.com/rust/rust-object.html

# 关于面向对象

* 解释：面向对象的编程语言通常实现了数据的封装与继承并能基于数据调用方法。
* 有：js一切都是对象
* 无：Rust 不是面向对象的编程语言，但这些功能都得以实现。

# React状态管理

* Redux
    * 通过props注入 dispatch/state，规避了 useContext 方案可能导致的重复渲染
* Mobx （有点类似createContext + useContext + reactivity）
    * 特征：Mobx + React 类似等于 Vue
* createContext + useContext + useReducer
    * 坑：createContext 返回的 Provider 中 value变化会触发所有子组件重复渲染
        * 关联思考：这种方案适用于小型的状态管理？
    * Todo：了解重复渲染的运转机制
    * 优化：对渲染做 useMemo
# 文章精读之前端框架设计
## 组件类型
    
* 纯展示型的组件，数据进，DOM出，直观明了
* 接入型组件，在React场景下的container component，这种组件会跟数据层的service打交道，会包含一些跟服务器或者说数据源打交道的逻辑，container会把数据向下*传递给展示型组件
* 交互型组件，典型的例子是对于表单组件的封装和加强，大部分的组件库都是以交互型组件为主，比如说Element UI，特点是有比较复杂的交互逻辑，但是是比较通用的逻辑，强调组件的复用
* 功能型组件，以Vue的应用场景举例，路由的router-view组件、transition组件，本身并不渲染任何内容，是一个逻辑型的东西，作为一种扩展或者是抽象机制存在

## 状态管理
如何管理将事件源映射到状态变化的过程，如何将这个映射的过程从视图组件中剥离出来，如何组织这一部分代码来提高可维护性，是状态管理要解决的本质问题
## CSS方案
* css modules
* css-in-js
## 构建工具
解决的问题
* 任务的自动化
* 开发体验和效率（新的语言功能，语法糖，hot reload 等等）
* 部署相关的需求
* 编译时优化
## Reference
* [Evanyou 聊聊前端框架](https://juejin.cn/post/6844903510455107598)

# CSS Animation,Transition 原理
* GPU比较擅长于：

    - 绘制位图到屏幕

    - 重复的绘制同一个位图

    - 在不同的位置，以不同的旋转角度，或者不同的缩放大小来绘制同一个位图。

* GPU相对慢的地方：

    - 将位图加载到显存里。

例子：
```css
/*hover的时候height变化 100 -> 200的过程中重复计算元素当前位图然后回传给GPU绘制*/
div {   
    height: 100px;   
    transition: height 1s linear;   
}   

div:hover {   
    height: 200px;   
} 

/*
CSS的transform属性不会改变元素的布局，也不会影响到其周围的元素。它把元素当做一个整体看待——缩放整个元素、旋转整个元素或者移动整个元素。
所以位图只会在cpu跟GPU 之间传递一次，scale的重新绘制只发生在GPU，而不会阻塞主线程，也就是更加流畅？
*/
div {   
    transform: scale(0.5);   
    transition: transform 1s linear;   
}   
     
div:hover {   
    transform: scale(1.0);   
}  
```
## 总结
选择独立性比较强的CSS属性有助于改善动画效果：transform，opacity，filter （依赖于过滤器的复杂度和浏览器）

拓展：渲染线程分为 主线程 (main thread) 和 合成线程 (compositor thread)
## Reference
* https://www.jb51.net/css/348357.html

# Vue运行时错误处理
Vue源码里面lifeCycle/watch/directive/transition等的callback/hook等一般会被封装执行
```js
 const res = callWithAsyncErrorHandling(hook, target, type, args)
 ```
* 封装执行要素：  
    - fn: Function,
    - instance: ComponentInternalInstance | null,
    - type: ErrorTypes,
* 错误分类：LifecycleHooks | ErrorCodes（其他函数执行点：callback + hook等）
* 同步错误处理：尝试函数运行处理同步错误，并搜集返回值
* 异步错误处理：根据返回值是否Promise来处理异步错误
## Reference

* [@vue/runtime-core/errorHandling](https://github.com/vuejs/core/blob/main/packages/runtime-core/src/errorHandling.ts)

# 插件对比（Vue vs React）

## 插件
1. Vue插件
```js
// calls `MyPlugin.install(Vue)`
Vue.use(MyPlugin)

new Vue({
  //... options
})
/**
 * 
 * 适配 Vue3的 Composition-API场景
 * 1. 在MyPlugin初始化阶段 app.provide(injectKey)注入实例
 * 2. 在MyPlugin use阶段 app.inject(injectKey)获取实例
 * 
 * Class 场景
 * 1. 初始化阶段 把 MyPlugin 逐步 mixin 到子组件
 * 2. 调用阶段直接在组件实例上获取
```
2. React插件
```js
// 例子
 <Provider store={store}>
 </Provider>
 ```
 // 使用地方：一般需要对组件做二次封装进行connect，然后可以useDispatch，**类似Vue inject？**
### 插件的插件（Vuex vs Redux）
1. Vuex插件
```js
// 插件模板
const myPlugin = (store) => {
  // called when the store is initialized
  store.subscribe((mutation, state) => {
    // called after every mutation.
    // The mutation comes in the format of `{ type, payload }`.
  })
}
```
```js
// 插件使用
const store = createStore({
  // ...
  plugins: [myPlugin]
})
```
// 插件案例
[vuex-persistedstate](https://github.com/robinvdvleuten/vuex-persistedstate)通过对mutation的拦截，对模块paths进行精准持久化

2. Redux 中间件
```js
// 插件例子
const logger = store => next => action => {
  console.log('dispatching', action)
  let result = next(action)
  console.log('next state', store.getState())
  return result
}
```
```js
// 插件使用
import { createStore, combineReducers, applyMiddleware } from 'redux'

const todoApp = combineReducers(reducers)
const store = createStore(
  todoApp,
  // applyMiddleware() tells createStore() how to handle middleware
  applyMiddleware(logger, crashReporter)
)

```
// 复杂案例
[redux-persist](https://github.com/rt2zz/redux-persist#nested-persists)
### 插件的插件的插件
1. redux-persist的插件，或者称为 Transforms
例子
```js
import createExpirationTransform from 'redux-persist-transform-expire';

const expireTransform = createExpirationTransform({
  expireKey: 'customExpiresAt',
  defaultState: {
    custom: 'values'
  }
});

persistStore(store, {
  transforms: [expireTransform]
});
```

## 总结
Vue的mutable 比 React的immutable对数据的状态的操作来的直接，导致在状态处理插件模式也会不同；vuex（直接mutation改变数据）整体上比redux（通过dispatch action，走整个reducer流程返回新的state）更加直接，导致插件模式上vuex直接劫持mutation比redux劫持reducer来的更加简单
## Reference
* https://vuex.vuejs.org/guide/plugins.html
* https://redux.js.org/understanding/history-and-design/middleware
* https://v2.vuejs.org/v2/guide/plugins.html?redirect=true

# 模拟LRU的数据结构（Set vs Array）
Set会自动追踪插入的先后顺序

1. Set结构
```js
let s = new Set()

s.add(3)
s.add(2)

// make this key the freshest
s.delete(3)
s.add(3)

// get Oldest
console.log(s.values().next().value); //2
```

2. Array结构
```js
let s = []

s.push(2)
s.push(3)

// make this key the freshest
s.splice(s.indexOf(3))
s.push(3)

// get Oldest
console.log(s[0])
```

# ORM 模块组成

* ORM
    * ORM
        * Engine (open db, connect dialect and db_path)
        * Session(prepare for next operation,  open/close DB)
    * Dialect 
        * dialect : db and dialect container
        * sqlite3 : language type <- map -> db column type
        * mysql ...
    * Schema (Parse a struct to a Schema instance)
        * 静态语言（例如 golang）：type struct（Modal） <- 反射 -> Table Fields 
        * 动态语言（例如 js）：手动 Table Fields 创建 -> Table Fields
    * Clause (SQL Builder)
        * generator: keyword sql string(vars) generation
        * clause : depend on generator, set/build final sql string
    * Session ( SQL Execution )
        * raw: raw sql execution
        * table: table operation
        * record: ORM Open API (Find/Select/Update/Delete/Where/Limit ...) ,depend on Clause/clause & table & raw
        * hooks: ORM Open API hook
        * transaction: Atomicity/Consistency/Isolation/Durability
        * migration
# [如何评价世界是一个草台班子](https://www.zhihu.com/question/589964007/answer/3584445924?utm_medium=social&utm_psn=1817523425624875008&utm_source=wechat_timeline)

* 反映了决策层和执行层之间的脱节现象。决策层虽然有大局观，但在执行细节上往往不够深入；
* 执行层尽管懂得如何完成任务，却缺乏对全局的理解。
* 信息传递的障碍加剧了这种脱节，导致决策无法得到有效执行，形成了一种低效的系统。

# 悲观者正确，乐观者成功

悲观者尝试的概率小，不太可能直面风险；但是乐观者会去尝试，有一定概率遭遇风险，但也有一定概率会成功。

# 技术弱势群体

未来的高科技社会，大多数人恐怕都是技术弱势群体，没有太多机会，技术优势集中在少数人手里。

# 康威定律 
Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure. 软件系统的架构看起来与构建它的开发团队的组织结构非常相似。
* [博客文摘部分](https://www.ruanyifeng.com/blog/2024/03/weekly-issue-291.html)
* [ConwaysLaw](https://martinfowler.com/bliki/ConwaysLaw.html)

# 维基百科通向哲学现象

（Wikipedia's "Getting to Philosophy" phenomenon）。当你点击每篇文章的第一个非括号中的链接，并不断重复这个过程，大约90%以上的情况下最终会到达“哲学”这个条目。**维基百科的条目结构趋向于层次化的知识体系，通往更抽象的概念。这种体系有助于引导阅读者从具体到抽象进行理解**，因此最终会引导到像“哲学”这样探讨最为根本性问题的学科。

# 崖山之后无中华
“崖山之后无中华”可以理解为中华的“气质”在崖山之战后发生了变化。宋朝时期，中华文明的气质更多体现在对文化和科技的崇尚、对创新的追求以及相对开放的心态。而崖山之后的元、明、清三朝，文化与科技的发展逐渐走向保守和停滞，更加注重政权稳固和经济利益，创新动力不足，文化气质发生了显著的转变。

# 卡钦斯基的警告 
[卡钦斯基：论工业社会及其未来](https://z.arlmy.me/Wiki/library/Original_Kaczynski_IndustrialSocietyAndItsFuture.html)
# 视频学习胜过读书吗？
* 人类学习效率最高的方式，不是"读书 + 思考"，而是"观察 + 模仿"
* 大部分领域的入门方式，都是"观察和模仿"，所以视频学习更有效。 对于深入学习，文字和书籍的效果可能好于视频，因为入门以后再往上走，"理解 + 思考"的作用越来越大，"观察 + 模仿"的作用越来越小。
# 雷军2024年度演讲：人生不能后退！
* [雷军2024年度演讲：人生不能后退！](https://www.mbachina.com/html/xw/202407/592986.html)
# 无人驾驶汽车投放

为了社会稳定，政府需要对无人驾驶出租车有所限制。

投放策略建议 - 摘抄自[阮一峰周刊](https://www.ruanyifeng.com/blog/2024/07/weekly-issue-309.html)

* （1）货运优于客运。货运的距离长，更艰苦，更适合无人驾驶。

* （2）公交车优于出租车。公交车本来就缺少司机，无人驾驶可以增加班次，有利于绿色出行。

* （3）郊区和农村优于城区，那里平时不容易叫车，更需要无人驾驶。

* （4）城区的无人驾驶出租车，政府收取管理费，使得运价不低于真人司机。多收的钱用于补贴出租车行业转型。

# 关于认知 更改时间（2023-2-24）

越来越感觉到认知能力才是事情发展的关键，认知是基础然后才是生成要素的聚集；太聚焦在解决问题层面，陷入到具体实现细节的可能不是一个好的开发

**认知的排序以及问题的解决流程**

1. 发现问题
2. 定义问题
3. 分解问题
4. 问题排序
5. 解决问题（可能是大部分人停留的阶段）

基层干部需要**分解问题**能力，然后是其他生产要素的收集（安排优先级，找到合适的人，定一个完成时间等）

重要核心岗位需要**发现问题**的能力，比起知道如何做，更需要找到值得去做的事情（方向不对，努力白费），然后才是技术介入，定义问题解决问题；
* 随着 chatGPT 等人工智能的发展，提出发现一个好问题可能比单纯解决问题更能匹配人机协作的未来；（目前 AI 还只能在给定问题框架下寻找答案，还没有迹象表明 AI 的自主目的性，一切还都是服务于人投喂的目的）

关于认知的例子:

流媒体：看下netflix跟国内的爱优腾的区别，前者自研内容飞涨带着股价飞涨，后者还在天价争夺版权，亏损到现在，爱奇艺最近（2021年底）大裁员了

技术界：前端大神Evanyou，产出了Vue，之后又诞生了vite，能在合适的时机出手带领一波技术潮流；除了技术强，核心可能在于领先同行的认知水平

# 关于沟通
1. 首先得把概念澄清
    * 划分概念边界（定义解决的问题类型，例如：vue-cli plugin可以定义成面向工程结构的开发；解释webpack plugin则是面向源码的转换开发）
    * 类比熟悉概念（例如：解释 vue-cli的plugin机制，就可以类比 webpack plugin机制）
## 提纲挈领

提纲挈领：比喻善于抓住问题的关键与要害；

### 前端

抓住核心可以事半功倍；比如：
1. 月经问题：Vue跟React的区别？核心在于Immutable跟Mutable这个理念，其他很多都是在此上的衍生问题
2. Webpack跟Vite区别？核心在真正按需的理念


# 关于自举
编程里面有个概念叫：自举；
>编程语言自己编译自己，重复这个过程可以让本身进化
>>例如：辅助增添新的语言特征，新的特征必须要能用旧的版本来编译解析，也叫向后兼容；
>>理论上编程语言可以通过自举来完成自身进化，不过更多只是体现在已有概念重组跟语法糖上，没法在底层上做大的改进

>rust的出现的其中一个原因就是为了摒弃语言的历史包袱，实现一个真正意义的高级语言

学习知识的过程也可以理解成“自举”
>通过自身已知概念来解释新知识，将新知识逐步建立在旧知识体系之上，从而“学习到”新知识
>>例如：小学算术是从简单1+1=2，再用个位解释灌输十位，用十位解释百位...再例如：学习编程，有C++基础学js语言会比有js基础再学C++简单

在变化中寻找自举的底层动力，不要怕吭硬骨头，了解底层编程模型范式更能增加自举进化可能性

# 关于快速学习
通性：跟随该领域领军人物的动态
Why/What/How
## 编程的世界

### 熟悉一门新语言
* 诞生的背景
    * 解决了哪些历史问题？
    * 为什么没有选择现有语言？
* 应用场景
    * 以前的解决方案，选择这门语言的优势
* 独有的特性并实践
* 语法
    * 内存对齐策略
    * 判定相等
        * javascript: 2个单独声明的对象不会相等，eg: let a ={name:1},b={name:1}; a!=b
        * golang: var p1 = point{x: 1, y: 2}; var p2 = point{x: 1, y: 2}; p1==p2
    * 组合还是继承？

### 新框架
    * 尝试造一个类似的轮子，基本能懂一半
## 学科
1. 从哪里划分出来？为什么被划分？
2. 解决的独有问题
3. 个人的应用

# 关于新技术应用
* 新技术的成熟度
* 渐进式使用，先在dev应用
* 分享，集思广益
* 落地

例子：应用@swc/core到系统考虑点，[参考这里](https://zhuanlan.zhihu.com/p/386730674)
1. 框架自身的需要能做到和 babel 解耦；
2. 自身使用的插件需要使用 swc plugin 再实现一遍；可能带来的副作用：
    1. 对 bundle 体积的影响；
    2. 转换后的代码是否存在兼容性问题；
    3. 如何快速的将 babel 插件转换到 swc 插件；
    4. swc 现有的能力是否满足从 babel 切换到 swc。
# 关于动静结合

## 编程语言层面
* 动态语言（JIT+VM动态编译执行，例如js）；
    * 优点：动态下发，容易做热替换，热更新等；dev体验好
    * 缺点：production性能较差

* 静态语言（AOT编译成二进制+Runtime，例如C）
    * 优点：production性能较好
    * 缺点：无法动态下发，没法热替换，dev需要等待编译完成

flutter选在dart语言（动静结合）,dev下JIT，production阶段AOT；兼顾dev跟production

## 性格
* 好动的人
    * 优点：社交牛逼症
    * 缺点：沉下心来搞研究难
* 喜静的人
    * 优点：能沉下心来琢磨事情
    * 缺点：社交困难
做一个动静结合的人？既能沉下来搞研究，也能出去处理人际关系

# 关于加班

* 有意义、有价值和能成长的忙碌不会让人产生真正疲惫，反而是不断焕发新的激情；
* 在错误的方向，复杂的人事上内耗会让人心力交瘁，即便准点下班也会心理疲惫；

# 关于中间层

一段话：所有的问题都能通过加一层中间层解决，如果不行，那就再加一层；

中间层的好处是屏蔽细节，简化API，增大通用性，但是以损失性能为代价
## 编程世界

例子：
* [N-API](https://blog.poetries.top/node-learning-notes/notes/advance/-node8_napi.html#n-api%E7%AE%80%E4%BB%8B)解决Node addon跟V8 API强绑定导致的升级困难；猜想大概率是做了一个 开发 Node Addon的通用API规范（底层可能还是通过封装V8实现，但是开发者不需要关心具体的V8 API是啥）
* Taro3 能做到框架独立（同时支持react/vue等框架语法），也是在编译中间加了一层编译IR，然后把IR再转换成对应的目标代码
* React 能做到编写 APP，也是在代码编译中加了一层虚拟DOM中间层 IR（如果是直接编译到浏览器Dom就没跨端什么事了），可以进行不同平台的适配
* LLVM 做成了标准的编译中间层IR，方便无数的新生语言（eg：Rust）可以以 LLVM 作为目标来编译，而无需去适配不同的操作系统
* JsBridge原理连接了js世界跟Native世界，丰富了js的可能性，代价是JsBridge沟通的性能损失
...

## 生活世界

* 如果一件事情处理不了，那就找人帮忙，如果还不行，那就再找一个人？
* 各种网络平台也就是把自己做成一个中间层，方便人事的协同？

# 关于补救方案

事物无时无刻都在向前发展，很多发展中的问题都是不可预测，所以基本没有一开始就设计出的完美的方案，于是补救方案就来了；当前的补救方案可能促进方案的成长

## 编程

* 当开发者跟Rust语言对Safe的场景认同不一致的时候，Rust决定把选择权交给开发，于是有了Unsafe；如果开发者正确，那可能是Rust进化的不错机会；例如：extern关键字协助创建外部函数接口（Foreign Function Interface， FFI），extern的函数就肯定是Unsafe的，因为rust没法进行静态检测其他语言的
* 当开发者跟typescript对lint的场景认同不一致的时候，于是有了 "//@ts-ignore"；可能是TS进化的机会

## 人类

* 认知的补救方案，早期人类遇到无法解释的现象首先是发挥想象力，创造一个万能的神明；
* 关于个人无法化解的场景，可能通过笑来化解；所以笑是避免大脑死机的补救方案？

# 关于趋势

事物的发展都有一定的规律，把握了正确规律可以事半功倍

## 计算机相关

* 语言的发展：更快、更安全、更容易掌握、特定问题的更好解决方案
    * Rust就是比C++更友好更安全的方向
    * Go 就是来提供更好的服务并发方案



# 关于js原型链

## 有意思的现象

```js
function A(name){
    this.name = name
}

Function.prototype.age = 1

let a = new A('a') // a是一个非函数的对象了

console.log(a.age); // undefined；原因：a.__proto__ === A.prototype ，A.prototype.__proto === Object.prototype

console.log(A.call); // 有值；原因：A.__proto__ === Function.prototype


```

# 关于GC

## 手动
方式：new/delete等手动方式
语言：C++等
优点：灵活
缺点：忘记或者回收不当会导致内存泄漏风险

## 自动 
* 方式：引用计数，标记清扫，节点复制，新老生代转化组合等；周期性的暂停程序执行而进行GC工作
* 典型的语言：js，go
* 优点：编写简单
* 缺点：GC频繁会导致程序执行性能受到影响

## 无GC
* 方式：所有权
* 语言：Rust
* 优点：性能高，安全
* 缺点：学习曲线陡峭
* 思考：实际有GC，只是效率高到不会妨碍到现有程序执行？

摘要
>Rust would know when the variable gets out of scope or its lifetime ends at compile time and thus insert the corresponding LLVM/assembly instructions to free the memory.

## Reference
* [what-does-rust-have-instead-of-a-garbage-collector](https://stackoverflow.com/questions/32677420/what-does-rust-have-instead-of-a-garbage-collector?noredirect=1&lq=1)

# React 踩坑之路由动画
例子：react-router-dom 从版本 6 开始就废弃了Switch组件，用Routes做了替换，然而使用上跟Switch有差别？第三方库 react-router-transition 目前依赖peerDependency react-router-dom@5，也就是升级react-router-dom直接崩？又因为breaking change的差异大，导致 react-router-transition 没法简单就能跟随升级
相关文档：[[Feature]: Compatibility layer that implements the v5 API ](https://github.com/remix-run/react-router/issues/8695)

* 现状：现在找个解决方案费时费力，各种实践层出不穷，核心库的breaking change没经过周全的思考就去实施，然后就是一堆填坑的工作量；
* 建议：React能否学习Vue把最佳实践维护起来，优势：可以做更周全稳定迭代，方便开发者找到最佳实践，提升工作效率；劣势：是啥？

# 数据结构疑问

* 数据结构之间的依赖关系：例如 golang map 依赖 hashmap ，hashmap依赖 数组 + 链表

***个人拙见，酌情观看***


# 一句话总结
* 生成对抗网络（GAN） VS 变分自编码器（VAE）： GAN 倾向于生成逼真的合成样本，而 VAE 倾向于生成具有一定程度多样性的样本。
    * [GAN 基本原理及其应用](https://easyai.tech/ai-definition/gan/)
* VIT - Google推出了VIT（Vision Transformer）：一个和Bert几乎一致，同时不添加任何卷积结构的图像分类模型。VIT在Transformer上的成功，证明了可以用统一的模型，来处理不同领域（语言/图像/视频）的任务，进而开启了多模态模型研究的新篇章。
* 文摘 - 高手解决问题的方式从来都不是纠结问题本身，而是升维；升维成功，问题也就解决了
* 雷军2023演讲 - 如何快速学习：知识不全是线性的，大部分是网状的，知识点之间不一定有绝对的先后关系；前面内容看不懂，跳过去，并不影响学后面的；后面的学会了，有时候更容易看懂前面的。
## AGI 的一点理解

机器学习训练了很多模型，而 LLM 只是其中之一；
ChatGPT 之所以跟 AGI 最接近，是因为语言模型的通用性；
如果能够理解自然语言，那就可以实现所有文字能够描述的任务；
其他 AI 任务，比如图片识别，则只能做到图片相似度能人物处理（推荐），无法拓展到相对通用的任务，除非日常交流能够通过表情包完成

## AI 前后数据的表现形式的一种猜想
AI 前：输入（字符数据写入） -> 存储（MySQL 等二维表存储字段（字符串））-> 输出（1维或者几个维度的索引匹配查询）

AI 后：输入（图片等 转为向量数组） -> 存储（向量（数组）数据库）-> 输出（N维索引，寻找相似度比较高的结果）

## gpt 可能的研究方向

* 建设高难度的综合任务评测数据集（LLM 的测试用例，越完备 -> 越强大）
* 高质量数据工程（密集+多样性）：LLM 进化 = 更多高质量数据
    * 数据例子
        * 密度极高的高质量数据：wiki
        * 高质量问答：quora，知乎
        * 高质量图片：
    * 思考
        * 高质量数据消耗完后 gpt 如何进化？
        * 能否自己创造知识自己消费（类似 alpha-go 自我对弈的进化）？
        * 如果 gpt 成长的资料来源于人类，那能否突破人类知识的边界？
* 探索 LLM 模型的规模天花板：大模型大数据，能参与的玩家不多
    * 思考：是否会出现共建超大模型
* 增强 LLM 的复杂推理能力
* LLM 纳入 NLP之外更多其它研究领域：多模态？
    * 如何突破符号领域？如果某个领域是非成文的，不能用符号记录表达，那么 GPT 是否就无能为力。比如，人类的很多心理活动、潜意识、灵感、顿悟等等，GPT 如何模拟生成。
* 更易用的人和LLM的交互接口：听觉？
* 超大LLM模型Transformer的稀疏化：相同算力下提高训练速度

参考
* [通向AGI之路：大型语言模型（LLM）技术精要](https://zhuanlan.zhihu.com/p/597586623)
# 关于 chatGPT 引发的人工智能思考 2023-3-1

* 人跟AI的关系：淘汰还是互补？
    * 人有自主目的性（AI暂无），AI是实现目的的工具；
* 提问跟回答能力，哪个更能生存下来？
    * 往后提出好问题能力的重要性将越来越超过回答问题能力
* 教育
    * 投喂答案的教育模式需要变革 -> 把提问能力列入考核标准，更能培养出人机协作人才
    * 让人利用机器，而不是把人培养成机器
    * 文理分科这种教育模式急迫需要改变：chatGPT 需要文理结合，提好问题，同时认清答案

## chatGPT 衍生的未来职业？（更新 2023-3-13，[参考](https://www.youtube.com/watch?v=UsaZhQ9bY2k)）

场景跟问题
* 更精准提出需求，才能利用好 chatGPT
* 辅助 chatGPT 修正回答错误，同时又不影响模型输出的其他答案
* 检测回答是否由机器生成
* 如何避免 chatGPT 泄密，如何做隐私保护（目前可以 chatGPT 被催眠然后突破本身不泄密的限制）
* AI 训练，避免伦理问题
* AI 本身安全：解决提示注入（类似 网页的 xss ，SQL 注入等），越狱等安全问题
* 知识产权重新定义：AI生成的东西到底算不算侵权？（例如之前的爬别人网站的数据作为自身的商业盈利依据，是否算侵权？）
* 趋势预测
    * 动作（运动，游戏等数据）文件化：可以对整场羽毛球做文字标记序列化，然后输入 chatGPT，最后可以预测落点跟个人行为

职业名？
* 标注师：标记信息，投喂并训练 AI
* 安全员：确保 AI 不被攻破

gpt自己的回答
* 提示工程师：提示是一种指导GPT-4生成内容的文本或图像，通常包含一些特殊的符号或指令。提示工程师就是专门设计和优化提示的人员，他们需要了解GPT-4的内部机制和逻辑，以及不同领域和场景下用户的需求和偏好。提示工程师可以为各种应用场景提供高质量、高效率、高安全性的提示服务。
* 内容审核员：虽然GPT-4具有强大的生成能力，但它也可能会产生一些不合适或有害的内容，如色情、暴力、歧视、谣言等。内容审核员就是负责检查和过滤GPT-4生成内容中是否存在这些问题，并及时删除或修改不良内容。内容审核员需要具备一定的专业知识和判断能力，以及良好的道德素养和责任心。
* 内容运营师：内容运营师是利用GPT-4为各种平台和渠道提供优质内容服务的人员，他们需要根据目标受众和市场需求，选择合适的提示和参数来调用GPT-4生成相应类型和风格的内容，并进行编辑、优化和发布。内容运营师需要具备一定的创意思维和文案能力，以及对各种媒体平台和行业动态有一定了解。
* 内容创作者：内容创作者是利用GPT-4辅助自己进行创作活动的人员，他们可以将自己想要表达或传达给用户

# 关于认知 更改时间（2023-2-24）

越来越感觉到认知能力才是事情发展的关键，认知是基础然后才是生成要素的聚集；太聚焦在解决问题层面，陷入到具体实现细节的可能不是一个好的开发

**认知的排序以及问题的解决流程**

1. 发现问题
2. 定义问题
3. 分解问题
4. 问题排序
5. 解决问题（可能是大部分人停留的阶段）

基层干部需要**分解问题**能力，然后是其他生产要素的收集（安排优先级，找到合适的人，定一个完成时间等）

重要核心岗位需要**发现问题**的能力，比起知道如何做，更需要找到值得去做的事情（方向不对，努力白费），然后才是技术介入，定义问题解决问题；
* 随着 chatGPT 等人工智能的发展，提出发现一个好问题可能比单纯解决问题更能匹配人机协作的未来；（目前 AI 还只能在给定问题框架下寻找答案，还没有迹象表明 AI 的自主目的性，一切还都是服务于人投喂的目的）

关于认知的例子:

流媒体：看下netflix跟国内的爱优腾的区别，前者自研内容飞涨带着股价飞涨，后者还在天价争夺版权，亏损到现在，爱奇艺最近（2021年底）大裁员了

技术界：前端大神Evanyou，产出了Vue，之后又诞生了vite，能在合适的时机出手带领一波技术潮流；除了技术强，核心可能在于领先同行的认知水平

# 关于沟通
1. 首先得把概念澄清
    * 划分概念边界（定义解决的问题类型，例如：vue-cli plugin可以定义成面向工程结构的开发；解释webpack plugin则是面向源码的转换开发）
    * 类比熟悉概念（例如：解释 vue-cli的plugin机制，就可以类比 webpack plugin机制）
## 提纲挈领

提纲挈领：比喻善于抓住问题的关键与要害；

### 前端

抓住核心可以事半功倍；比如：
1. 月经问题：Vue跟React的区别？核心在于Immutable跟Mutable这个理念，其他很多都是在此上的衍生问题
2. Webpack跟Vite区别？核心在真正按需的理念


# 关于自举
编程里面有个概念叫：自举；
>编程语言自己编译自己，重复这个过程可以让本身进化
>>例如：辅助增添新的语言特征，新的特征必须要能用旧的版本来编译解析，也叫向后兼容；
>>理论上编程语言可以通过自举来完成自身进化，不过更多只是体现在已有概念重组跟语法糖上，没法在底层上做大的改进

>rust的出现的其中一个原因就是为了摒弃语言的历史包袱，实现一个真正意义的高级语言

学习知识的过程也可以理解成“自举”
>通过自身已知概念来解释新知识，将新知识逐步建立在旧知识体系之上，从而“学习到”新知识
>>例如：小学算术是从简单1+1=2，再用个位解释灌输十位，用十位解释百位...再例如：学习编程，有C++基础学js语言会比有js基础再学C++简单

在变化中寻找自举的底层动力，不要怕吭硬骨头，了解底层编程模型范式更能增加自举进化可能性

# 关于快速学习
通性：跟随该领域领军人物的动态
Why/What/How
## 编程的世界

### 熟悉一门新语言
* 诞生的背景
    * 解决了哪些历史问题？
    * 为什么没有选择现有语言？
* 应用场景
    * 以前的解决方案，选择这门语言的优势
* 独有的特性并实践
* 语法
    * 内存对齐策略
    * 判定相等
        * javascript: 2个单独声明的对象不会相等，eg: let a ={name:1},b={name:1}; a!=b
        * golang: var p1 = point{x: 1, y: 2}; var p2 = point{x: 1, y: 2}; p1==p2
    * 组合还是继承？

### 新框架
    * 尝试造一个类似的轮子，基本能懂一半
## 学科
1. 从哪里划分出来？为什么被划分？
2. 解决的独有问题
3. 个人的应用

# 关于新技术应用
* 新技术的成熟度
* 渐进式使用，先在dev应用
* 分享，集思广益
* 落地

例子：应用@swc/core到系统考虑点，[参考这里](https://zhuanlan.zhihu.com/p/386730674)
1. 框架自身的需要能做到和 babel 解耦；
2. 自身使用的插件需要使用 swc plugin 再实现一遍；可能带来的副作用：
    1. 对 bundle 体积的影响；
    2. 转换后的代码是否存在兼容性问题；
    3. 如何快速的将 babel 插件转换到 swc 插件；
    4. swc 现有的能力是否满足从 babel 切换到 swc。
# 关于动静结合

## 编程语言层面
* 动态语言（JIT+VM动态编译执行，例如js）；
    * 优点：动态下发，容易做热替换，热更新等；dev体验好
    * 缺点：production性能较差

* 静态语言（AOT编译成二进制+Runtime，例如C）
    * 优点：production性能较好
    * 缺点：无法动态下发，没法热替换，dev需要等待编译完成

flutter选在dart语言（动静结合）,dev下JIT，production阶段AOT；兼顾dev跟production

## 性格
* 好动的人
    * 优点：社交牛逼症
    * 缺点：沉下心来搞研究难
* 喜静的人
    * 优点：能沉下心来琢磨事情
    * 缺点：社交困难
做一个动静结合的人？既能沉下来搞研究，也能出去处理人际关系

# 关于加班

* 有意义、有价值和能成长的忙碌不会让人产生真正疲惫，反而是不断焕发新的激情；
* 在错误的方向，复杂的人事上内耗会让人心力交瘁，即便准点下班也会心理疲惫；

# 关于中间层

一段话：所有的问题都能通过加一层中间层解决，如果不行，那就再加一层；

中间层的好处是屏蔽细节，简化API，增大通用性，但是以损失性能为代价
## 编程世界

例子：
* [N-API](https://blog.poetries.top/node-learning-notes/notes/advance/-node8_napi.html#n-api%E7%AE%80%E4%BB%8B)解决Node addon跟V8 API强绑定导致的升级困难；猜想大概率是做了一个 开发 Node Addon的通用API规范（底层可能还是通过封装V8实现，但是开发者不需要关心具体的V8 API是啥）
* Taro3 能做到框架独立（同时支持react/vue等框架语法），也是在编译中间加了一层编译IR，然后把IR再转换成对应的目标代码
* React 能做到编写 APP，也是在代码编译中加了一层虚拟DOM中间层 IR（如果是直接编译到浏览器Dom就没跨端什么事了），可以进行不同平台的适配
* LLVM 做成了标准的编译中间层IR，方便无数的新生语言（eg：Rust）可以以 LLVM 作为目标来编译，而无需去适配不同的操作系统
* JsBridge原理连接了js世界跟Native世界，丰富了js的可能性，代价是JsBridge沟通的性能损失
...

## 生活世界

* 如果一件事情处理不了，那就找人帮忙，如果还不行，那就再找一个人？
* 各种网络平台也就是把自己做成一个中间层，方便人事的协同？

# 关于补救方案

事物无时无刻都在向前发展，很多发展中的问题都是不可预测，所以基本没有一开始就设计出的完美的方案，于是补救方案就来了；当前的补救方案可能促进方案的成长

## 编程

* 当开发者跟Rust语言对Safe的场景认同不一致的时候，Rust决定把选择权交给开发，于是有了Unsafe；如果开发者正确，那可能是Rust进化的不错机会；例如：extern关键字协助创建外部函数接口（Foreign Function Interface， FFI），extern的函数就肯定是Unsafe的，因为rust没法进行静态检测其他语言的
* 当开发者跟typescript对lint的场景认同不一致的时候，于是有了 "//@ts-ignore"；可能是TS进化的机会

## 人类

* 认知的补救方案，早期人类遇到无法解释的现象首先是发挥想象力，创造一个万能的神明；
* 关于个人无法化解的场景，可能通过笑来化解；所以笑是避免大脑死机的补救方案？

# 关于趋势

事物的发展都有一定的规律，把握了正确规律可以事半功倍

## 计算机相关

* 语言的发展：更快、更安全、更容易掌握、特定问题的更好解决方案
    * Rust就是比C++更友好更安全的方向
    * Go 就是来提供更好的服务并发方案



# 关于js原型链

## 有意思的现象

```js
function A(name){
    this.name = name
}

Function.prototype.age = 1

let a = new A('a') // a是一个非函数的对象了

console.log(a.age); // undefined；原因：a.__proto__ === A.prototype ，A.prototype.__proto === Object.prototype

console.log(A.call); // 有值；原因：A.__proto__ === Function.prototype


```

# 关于GC

## 手动
方式：new/delete等手动方式
语言：C++等
优点：灵活
缺点：忘记或者回收不当会导致内存泄漏风险

## 自动 
* 方式：引用计数，标记清扫，节点复制，新老生代转化组合等；周期性的暂停程序执行而进行GC工作
* 典型的语言：js，go
* 优点：编写简单
* 缺点：GC频繁会导致程序执行性能受到影响

## 无GC
* 方式：所有权
* 语言：Rust
* 优点：性能高，安全
* 缺点：学习曲线陡峭
* 思考：实际有GC，只是效率高到不会妨碍到现有程序执行？

摘要
>Rust would know when the variable gets out of scope or its lifetime ends at compile time and thus insert the corresponding LLVM/assembly instructions to free the memory.

## Reference
* [what-does-rust-have-instead-of-a-garbage-collector](https://stackoverflow.com/questions/32677420/what-does-rust-have-instead-of-a-garbage-collector?noredirect=1&lq=1)

# React 踩坑之路由动画
例子：react-router-dom 从版本 6 开始就废弃了Switch组件，用Routes做了替换，然而使用上跟Switch有差别？第三方库 react-router-transition 目前依赖peerDependency react-router-dom@5，也就是升级react-router-dom直接崩？又因为breaking change的差异大，导致 react-router-transition 没法简单就能跟随升级
相关文档：[[Feature]: Compatibility layer that implements the v5 API ](https://github.com/remix-run/react-router/issues/8695)

* 现状：现在找个解决方案费时费力，各种实践层出不穷，核心库的breaking change没经过周全的思考就去实施，然后就是一堆填坑的工作量；
* 建议：React能否学习Vue把最佳实践维护起来，优势：可以做更周全稳定迭代，方便开发者找到最佳实践，提升工作效率；劣势：是啥？

# 数据结构疑问

* 数据结构之间的依赖关系：例如 golang map 依赖 hashmap ，hashmap依赖 数组 + 链表

***个人拙见，酌情观看***


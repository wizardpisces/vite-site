# [资本、AGI 与野心](https://rudolf.website/capital-agi-and-ambition/)

## mRNA 与传统疫苗
关键点：安全性、免疫效果、生产速度和稳定性

* mRNA（信使RNA）是细胞内的遗传指令载体，它负责将DNA上的遗传信息传递给细胞的核糖体，指导蛋白质合成。
    * 流程：设计mRNA -> 生产并包裹mRNA -> 注射mRNA
* 传统疫苗是利用灭活病毒、减毒病毒或重组蛋白等抗原物质，通过注射或口服等方式进入人体，激发免疫系统产生免疫反应。

当前还不能完全取代传统疫苗，原因：
* 细菌比病毒复杂，往往有多种抗原，mRNA疫苗很难涵盖所有关键抗原。
* 一些疫苗（如鼻喷雾流感疫苗、口服脊灰疫苗）在黏膜部位诱导免疫，防止病毒进入体内，而mRNA疫苗主要在肌肉注射，难以产生强大的黏膜免疫。


# QRCode 的黑块限制
1. 屏幕二维码的最小模块建议为 4像素 x 4像素。更大的会更容易被扫描识别
2. 印刷二维码的最小模块建议为 0.4毫米 x 0.4毫米。
# [vscode 括号着色](https://code.visualstudio.com/blogs/2021/09/29/bracket-pair-colorization)

# "准备悖论"

指的是，如果提前采取有效措施，就可以减轻某种未来的灾难，那么人们就会倾向于认为，这种灾难没有那么严重，不会造成太大损害，从而阻碍对这种灾难进行提前准备。

# [hacknews 评分前十的讲座](https://news.ycombinator.com/item?id=34591291)

# Geohash 原理

Geohash 是一种用于地理位置编码的算法，它将地球上的经纬度转换为一个字符串。这个字符串表示一个矩形区域而不是一个点。Geohash 的核心是不断对经纬度进行 二分区域，并将结果编码为二进制，再转换为更简洁的 Base32 字符串。

直观解释，把地球看作一个网格，每次增加一个字符（增加编码长度）就进一步细分网格。
比如：
* 9 表示一个大区域（经纬度粗分）。
* 9q 表示更小的区域。
* 9q8 表示更精确的区域。
* 9q8yy 可精确到几米范围内。

## **什么是 S2 编码？**

S2 是一种地理空间索引系统，基于球面几何将地球表面划分为一系列分层的单元（称为 S2 Cells）。每个单元都有唯一的 ID，用来表示地球上的区域。与 Geohash 不同，S2 直接在球面上工作，避免了平面映射中的失真。

## **对比 Geohash**
| 特性             | Geohash                   | S2 编码              |
|------------------|---------------------------|----------------------|
| 投影方式        | 平面投影                  | 球面投影            |
| 单元形状        | 矩形                      | 近似正方形          |
| 分层方式        | 字符编码（Base32）         | 整数 ID             |
| 精度与效率      | 适合简单应用              | 更适合复杂查询与计算 |


S2 在地图服务（如 Google Maps 和 Uber）中被广泛使用，适合处理高精度地理数据和邻近搜索场景。

# 牛鞭效应（Bullwhip Effect）

描述的是在供应链中，由于信息在各个环节间传递的不对称或延迟，小范围的需求波动会逐级放大，最终在上游（例如制造商或原材料供应商）形成更大的需求波动。这一现象形象地得名于牛鞭——手腕的小幅动作会在鞭梢引发巨大的波动。

* 举例说明
    * 消费者需求：某商品原本每周需要 10 个，突然需求升至 15 个。
    * 零售商：为了应对需求增长及库存不足，订购 20 个。
    * 批发商：考虑到运输周期和订单积压，向制造商订购 30 个。
    * 制造商：预测未来可能会有更高的需求，于是向供应商订购 50 个。
    * 最终，上游供应商感受到的需求远高于实际需求的 15 个，形成了牛鞭效应。

# 如果金钱统治世界，那么谁统治金钱？

答案是 那些有能力制造通货膨胀的人统治着金钱。他们首先借钱购买实物资产，通货膨胀之后，再用贬值的钱来还债。- [hacker news](https://news.ycombinator.com/item?id=37707208)

# [解决团队分歧的四种方式](https://www.businessweekly.com.tw/management/blog/3014278)
方式一：我不同意，但一旦决策定了，我就会一起努力。

亚马逊创始人贝佐斯说："当我跟一个主管反复讨论后，他不同意我的看法。虽然我不认为他正确，但我愿意陪他赌一把。我们认识几十年了，我觉得他可能比我更接近真相。其实我也不知道自己的决定是否正确，干脆照着下属的想法走。"

这样有几个好处：

* 至少产生了一个大家同意的决策。
* 事后不会互相埋怨。
* 有利于形成真正的团队精神。

# [如何评价世界是一个草台班子](https://www.zhihu.com/question/589964007/answer/3584445924?utm_medium=social&utm_psn=1817523425624875008&utm_source=wechat_timeline)

* 反映了决策层和执行层之间的脱节现象。决策层虽然有大局观，但在执行细节上往往不够深入；
* 执行层尽管懂得如何完成任务，却缺乏对全局的理解。
* 信息传递的障碍加剧了这种脱节，导致决策无法得到有效执行，形成了一种低效的系统。

# 悲观者正确，乐观者成功

悲观者尝试的概率小，不太可能直面风险；但是乐观者会去尝试，有一定概率遭遇风险，但也有一定概率会成功。

# 技术弱势群体

未来的高科技社会，大多数人恐怕都是技术弱势群体，没有太多机会，技术优势集中在少数人手里。

# 康威定律 
Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure. 软件系统的架构看起来与构建它的开发团队的组织结构非常相似。
* [博客文摘部分](https://www.ruanyifeng.com/blog/2024/03/weekly-issue-291.html)
* [ConwaysLaw](https://martinfowler.com/bliki/ConwaysLaw.html)

# 维基百科通向哲学现象

（Wikipedia's "Getting to Philosophy" phenomenon）。当你点击每篇文章的第一个非括号中的链接，并不断重复这个过程，大约90%以上的情况下最终会到达“哲学”这个条目。**维基百科的条目结构趋向于层次化的知识体系，通往更抽象的概念。这种体系有助于引导阅读者从具体到抽象进行理解**，因此最终会引导到像“哲学”这样探讨最为根本性问题的学科。

# 崖山之后无中华
“崖山之后无中华”可以理解为中华的“气质”在崖山之战后发生了变化。宋朝时期，中华文明的气质更多体现在对文化和科技的崇尚、对创新的追求以及相对开放的心态。而崖山之后的元、明、清三朝，文化与科技的发展逐渐走向保守和停滞，更加注重政权稳固和经济利益，创新动力不足，文化气质发生了显著的转变。

# 卡钦斯基的警告 
[卡钦斯基：论工业社会及其未来](https://z.arlmy.me/Wiki/library/Original_Kaczynski_IndustrialSocietyAndItsFuture.html)
# 视频学习胜过读书吗？
* 人类学习效率最高的方式，不是"读书 + 思考"，而是"观察 + 模仿"
* 大部分领域的入门方式，都是"观察和模仿"，所以视频学习更有效。 对于深入学习，文字和书籍的效果可能好于视频，因为入门以后再往上走，"理解 + 思考"的作用越来越大，"观察 + 模仿"的作用越来越小。
# 雷军2024年度演讲：人生不能后退！
* [雷军2024年度演讲：人生不能后退！](https://www.mbachina.com/html/xw/202407/592986.html)
# 无人驾驶汽车投放

为了社会稳定，政府需要对无人驾驶出租车有所限制。

投放策略建议 - 摘抄自[阮一峰周刊](https://www.ruanyifeng.com/blog/2024/07/weekly-issue-309.html)

* （1）货运优于客运。货运的距离长，更艰苦，更适合无人驾驶。

* （2）公交车优于出租车。公交车本来就缺少司机，无人驾驶可以增加班次，有利于绿色出行。

* （3）郊区和农村优于城区，那里平时不容易叫车，更需要无人驾驶。

* （4）城区的无人驾驶出租车，政府收取管理费，使得运价不低于真人司机。多收的钱用于补贴出租车行业转型。

# 关于认知 更改时间（2023-2-24）

越来越感觉到认知能力才是事情发展的关键，认知是基础然后才是生成要素的聚集；太聚焦在解决问题层面，陷入到具体实现细节的可能不是一个好的开发

**认知的排序以及问题的解决流程**

1. 发现问题
2. 定义问题
3. 分解问题
4. 问题排序
5. 解决问题（可能是大部分人停留的阶段）

基层干部需要**分解问题**能力，然后是其他生产要素的收集（安排优先级，找到合适的人，定一个完成时间等）

重要核心岗位需要**发现问题**的能力，比起知道如何做，更需要找到值得去做的事情（方向不对，努力白费），然后才是技术介入，定义问题解决问题；
* 随着 chatGPT 等人工智能的发展，提出发现一个好问题可能比单纯解决问题更能匹配人机协作的未来；（目前 AI 还只能在给定问题框架下寻找答案，还没有迹象表明 AI 的自主目的性，一切还都是服务于人投喂的目的）

关于认知的例子:

流媒体：看下netflix跟国内的爱优腾的区别，前者自研内容飞涨带着股价飞涨，后者还在天价争夺版权，亏损到现在，爱奇艺最近（2021年底）大裁员了

技术界：前端大神Evanyou，产出了Vue，之后又诞生了vite，能在合适的时机出手带领一波技术潮流；除了技术强，核心可能在于领先同行的认知水平

# 关于沟通
1. 首先得把概念澄清
    * 划分概念边界（定义解决的问题类型，例如：vue-cli plugin可以定义成面向工程结构的开发；解释webpack plugin则是面向源码的转换开发）
    * 类比熟悉概念（例如：解释 vue-cli的plugin机制，就可以类比 webpack plugin机制）
## 提纲挈领

提纲挈领：比喻善于抓住问题的关键与要害；

### 前端

抓住核心可以事半功倍；比如：
1. 月经问题：Vue跟React的区别？核心在于Immutable跟Mutable这个理念，其他很多都是在此上的衍生问题
2. Webpack跟Vite区别？核心在真正按需的理念


# 关于自举
编程里面有个概念叫：自举；
>编程语言自己编译自己，重复这个过程可以让本身进化
>>例如：辅助增添新的语言特征，新的特征必须要能用旧的版本来编译解析，也叫向后兼容；
>>理论上编程语言可以通过自举来完成自身进化，不过更多只是体现在已有概念重组跟语法糖上，没法在底层上做大的改进

>rust的出现的其中一个原因就是为了摒弃语言的历史包袱，实现一个真正意义的高级语言

学习知识的过程也可以理解成“自举”
>通过自身已知概念来解释新知识，将新知识逐步建立在旧知识体系之上，从而“学习到”新知识
>>例如：小学算术是从简单1+1=2，再用个位解释灌输十位，用十位解释百位...再例如：学习编程，有C++基础学js语言会比有js基础再学C++简单

在变化中寻找自举的底层动力，不要怕吭硬骨头，了解底层编程模型范式更能增加自举进化可能性

# 关于快速学习
通性：跟随该领域领军人物的动态
Why/What/How
## 编程的世界

### 熟悉一门新语言
* 诞生的背景
    * 解决了哪些历史问题？
    * 为什么没有选择现有语言？
* 应用场景
    * 以前的解决方案，选择这门语言的优势
* 独有的特性并实践
* 语法
    * 内存对齐策略
    * 判定相等
        * javascript: 2个单独声明的对象不会相等，eg: let a ={name:1},b={name:1}; a!=b
        * golang: var p1 = point{x: 1, y: 2}; var p2 = point{x: 1, y: 2}; p1==p2
    * 组合还是继承？

### 新框架
    * 尝试造一个类似的轮子，基本能懂一半
## 学科
1. 从哪里划分出来？为什么被划分？
2. 解决的独有问题
3. 个人的应用

# 关于新技术应用
* 新技术的成熟度
* 渐进式使用，先在dev应用
* 分享，集思广益
* 落地

例子：应用@swc/core到系统考虑点，[参考这里](https://zhuanlan.zhihu.com/p/386730674)
1. 框架自身的需要能做到和 babel 解耦；
2. 自身使用的插件需要使用 swc plugin 再实现一遍；可能带来的副作用：
    1. 对 bundle 体积的影响；
    2. 转换后的代码是否存在兼容性问题；
    3. 如何快速的将 babel 插件转换到 swc 插件；
    4. swc 现有的能力是否满足从 babel 切换到 swc。
# 关于动静结合

## 编程语言层面
* 动态语言（JIT+VM动态编译执行，例如js）；
    * 优点：动态下发，容易做热替换，热更新等；dev体验好
    * 缺点：production性能较差

* 静态语言（AOT编译成二进制+Runtime，例如C）
    * 优点：production性能较好
    * 缺点：无法动态下发，没法热替换，dev需要等待编译完成

flutter选在dart语言（动静结合）,dev下JIT，production阶段AOT；兼顾dev跟production

## 性格
* 好动的人
    * 优点：社交牛逼症
    * 缺点：沉下心来搞研究难
* 喜静的人
    * 优点：能沉下心来琢磨事情
    * 缺点：社交困难
做一个动静结合的人？既能沉下来搞研究，也能出去处理人际关系

# 关于加班

* 有意义、有价值和能成长的忙碌不会让人产生真正疲惫，反而是不断焕发新的激情；
* 在错误的方向，复杂的人事上内耗会让人心力交瘁，即便准点下班也会心理疲惫；

# 关于中间层

一段话：所有的问题都能通过加一层中间层解决，如果不行，那就再加一层；

中间层的好处是屏蔽细节，简化API，增大通用性，但是以损失性能为代价
## 编程世界

例子：
* [N-API](https://blog.poetries.top/node-learning-notes/notes/advance/-node8_napi.html#n-api%E7%AE%80%E4%BB%8B)解决Node addon跟V8 API强绑定导致的升级困难；猜想大概率是做了一个 开发 Node Addon的通用API规范（底层可能还是通过封装V8实现，但是开发者不需要关心具体的V8 API是啥）
* Taro3 能做到框架独立（同时支持react/vue等框架语法），也是在编译中间加了一层编译IR，然后把IR再转换成对应的目标代码
* React 能做到编写 APP，也是在代码编译中加了一层虚拟DOM中间层 IR（如果是直接编译到浏览器Dom就没跨端什么事了），可以进行不同平台的适配
* LLVM 做成了标准的编译中间层IR，方便无数的新生语言（eg：Rust）可以以 LLVM 作为目标来编译，而无需去适配不同的操作系统
* JsBridge原理连接了js世界跟Native世界，丰富了js的可能性，代价是JsBridge沟通的性能损失
...

## 生活世界

* 如果一件事情处理不了，那就找人帮忙，如果还不行，那就再找一个人？
* 各种网络平台也就是把自己做成一个中间层，方便人事的协同？

# 关于补救方案

事物无时无刻都在向前发展，很多发展中的问题都是不可预测，所以基本没有一开始就设计出的完美的方案，于是补救方案就来了；当前的补救方案可能促进方案的成长

## 编程

* 当开发者跟Rust语言对Safe的场景认同不一致的时候，Rust决定把选择权交给开发，于是有了Unsafe；如果开发者正确，那可能是Rust进化的不错机会；例如：extern关键字协助创建外部函数接口（Foreign Function Interface， FFI），extern的函数就肯定是Unsafe的，因为rust没法进行静态检测其他语言的
* 当开发者跟typescript对lint的场景认同不一致的时候，于是有了 "//@ts-ignore"；可能是TS进化的机会

## 人类

* 认知的补救方案，早期人类遇到无法解释的现象首先是发挥想象力，创造一个万能的神明；
* 关于个人无法化解的场景，可能通过笑来化解；所以笑是避免大脑死机的补救方案？

# 关于趋势

事物的发展都有一定的规律，把握了正确规律可以事半功倍

## 计算机相关

* 语言的发展：更快、更安全、更容易掌握、特定问题的更好解决方案
    * Rust就是比C++更友好更安全的方向
    * Go 就是来提供更好的服务并发方案



# 关于js原型链

## 有意思的现象

```js
function A(name){
    this.name = name
}

Function.prototype.age = 1

let a = new A('a') // a是一个非函数的对象了

console.log(a.age); // undefined；原因：a.__proto__ === A.prototype ，A.prototype.__proto === Object.prototype

console.log(A.call); // 有值；原因：A.__proto__ === Function.prototype


```

# 关于GC

## 手动
方式：new/delete等手动方式
语言：C++等
优点：灵活
缺点：忘记或者回收不当会导致内存泄漏风险

## 自动 
* 方式：引用计数，标记清扫，节点复制，新老生代转化组合等；周期性的暂停程序执行而进行GC工作
* 典型的语言：js，go
* 优点：编写简单
* 缺点：GC频繁会导致程序执行性能受到影响

## 无GC
* 方式：所有权
* 语言：Rust
* 优点：性能高，安全
* 缺点：学习曲线陡峭
* 思考：实际有GC，只是效率高到不会妨碍到现有程序执行？

摘要
>Rust would know when the variable gets out of scope or its lifetime ends at compile time and thus insert the corresponding LLVM/assembly instructions to free the memory.

## Reference
* [what-does-rust-have-instead-of-a-garbage-collector](https://stackoverflow.com/questions/32677420/what-does-rust-have-instead-of-a-garbage-collector?noredirect=1&lq=1)

# React 踩坑之路由动画
例子：react-router-dom 从版本 6 开始就废弃了Switch组件，用Routes做了替换，然而使用上跟Switch有差别？第三方库 react-router-transition 目前依赖peerDependency react-router-dom@5，也就是升级react-router-dom直接崩？又因为breaking change的差异大，导致 react-router-transition 没法简单就能跟随升级
相关文档：[[Feature]: Compatibility layer that implements the v5 API ](https://github.com/remix-run/react-router/issues/8695)

* 现状：现在找个解决方案费时费力，各种实践层出不穷，核心库的breaking change没经过周全的思考就去实施，然后就是一堆填坑的工作量；
* 建议：React能否学习Vue把最佳实践维护起来，优势：可以做更周全稳定迭代，方便开发者找到最佳实践，提升工作效率；劣势：是啥？

# 数据结构疑问

* 数据结构之间的依赖关系：例如 golang map 依赖 hashmap ，hashmap依赖 数组 + 链表

***个人拙见，酌情观看***


# 关于依赖管理

## Javascript
主流 npm/yarn/pnpm

* npm跟yarn比较类似，都是基于公共模块提升，依赖拍平
* pnpm基于symbolic link，天然支持多包工程

发展的大致方向

1. 安装速度
2. 占用空间
3. 稳定性
4. 对多包工程的支持
5. 系统兼容性

目前pnpm由于本身文件符号链接的安装原理，在安装速度/磁盘空间占用/多包工程支持上占据上风；顺带解决了npm跟yarn的幽灵引用（没在package.json声明的二手依赖却被使用了）以及同一个版本包多次安装（由于公共提升是按照版本提升，一个版本提升后其他的都会嵌套下去）的问题

### 有意思的现象

* pnpm Mono工程只有一个lock文件，在package下安装的依赖也会自动link到root下，并更新root的lock
* yarn workspace声称只有一个lock文件，但是在一个package下yarn add会再次生成一个local lock文件，并且把package的包重新安装在package下；然后在root执行yarn install，则才会提升依赖，然后更新root lock，但是local lock还是会保留；然后在package下yarn remove依赖，只是影响到local lock，root lock不会被同步更新，也就是root node_modules也不会被更新，除非再次在root执行yarn install；也就是在package操作后都得在root手动执行yarn install才会得到预期的效果
    * 疑问：为什么在package下的安装不能直接就以一个root lock为准？（pnpm就能不管在哪安装都只更新root lock）
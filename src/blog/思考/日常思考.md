# 关于认知

越来越感觉到认知能力才是事情发展的关键，认知是基础然后才是生成要素的聚集；太聚焦在解决问题层面，陷入到具体实现细节的可能不是一个好的开发

**认知的排序以及问题的解决流程**

1. 发现问题
2. 定义问题
3. 分解问题
4. 问题排序
5. 解决问题（可能是大部分人停留的阶段）

基层干部需要**分解问题**能力，然后是其他生产要素的收集（安排优先级，找到合适的人，定一个完成时间等）

重要核心岗位需要**发现问题**的能力，比起知道如何做，更需要找到值得去做的事情（方向不对，努力白费），然后才是技术介入，定义问题解决问题

关于认知的例子:

流媒体：看下netflix跟国内的爱优腾的区别，前者自研内容飞涨带着股价飞涨，后者还在天价争夺版权，亏损到现在，爱奇艺最近（2021年底）大裁员了

技术界：前端大神Evanyou，产出了Vue，之后又诞生了vite，能在合适的时机出手带领一波技术潮流；除了技术强，核心可能在于领先同行的认知水平

# 关于沟通
1. 首先得把概念澄清
    * 划分概念边界（定义解决的问题类型，例如：vue-cli plugin可以定义成面向工程结构的开发；解释webpack plugin则是面向源码的转换开发）
    * 类比熟悉概念（例如：解释 vue-cli的plugin机制，就可以类比 webpack plugin机制）
## 提纲挈领

提纲挈领：比喻善于抓住问题的关键与要害；

### 前端

抓住核心可以事半功倍；比如：
1. 月经问题：Vue跟React的区别？核心在于Immutable跟Mutable这个理念，其他很多都是在此上的衍生问题
2. Webpack跟Vite区别？核心在真正按需的理念


# 关于自举
编程里面有个概念叫：自举；
>编程语言自己编译自己，重复这个过程可以让本身进化
>>例如：辅助增添新的语言特征，新的特征必须要能用旧的版本来编译解析，也叫向后兼容；
>>理论上编程语言可以通过自举来完成自身进化，不过更多只是体现在已有概念重组跟语法糖上，没法在底层上做大的改进

>rust的出现的其中一个原因就是为了摒弃语言的历史包袱，实现一个真正意义的高级语言

学习知识的过程也可以理解成“自举”
>通过自身已知概念来解释新知识，将新知识逐步建立在旧知识体系之上，从而“学习到”新知识
>>例如：小学算术是从简单1+1=2，再用个位解释灌输十位，用十位解释百位...再例如：学习编程，有C++基础学js语言会比有js基础再学C++简单

在变化中寻找自举的底层动力，不要怕吭硬骨头，了解底层编程模型范式更能增加自举进化可能性

# 关于快速学习
通性：跟随该领域领军人物的动态
Why/What/How
## 编程的世界

### 熟悉一门新语言
1. 诞生的背景
    * 解决了哪些历史问题？
    * 为什么没有选择现有语言？
2. 应用场景
    * 以前的解决方案，选择这门语言的优势
3. 独有的特性并实践
### 新框架
    * 尝试造一个类似的轮子，基本能懂一半
## 学科
1. 从哪里划分出来？为什么被划分？
2. 解决的独有问题
3. 个人的应用

# 关于新技术应用
* 新技术的成熟度
* 渐进式使用，先在dev应用
* 分享，集思广益
* 落地

例子：应用@swc/core到系统考虑点，[参考这里](https://zhuanlan.zhihu.com/p/386730674)
1. 框架自身的需要能做到和 babel 解耦；
2. 自身使用的插件需要使用 swc plugin 再实现一遍；可能带来的副作用：
    1. 对 bundle 体积的影响；
    2. 转换后的代码是否存在兼容性问题；
    3. 如何快速的将 babel 插件转换到 swc 插件；
    4. swc 现有的能力是否满足从 babel 切换到 swc。
# 关于动静结合

## 编程语言层面
* 动态语言（JIT+VM动态编译执行，例如js）；
    * 优点：动态下发，容易做热替换，热更新等；dev体验好
    * 缺点：production性能较差

* 静态语言（AOT编译成二进制+Runtime，例如C）
    * 优点：production性能较好
    * 缺点：无法动态下发，没法热替换，dev需要等待编译完成

flutter选在dart语言（动静结合）,dev下JIT，production阶段AOT；兼顾dev跟production

## 性格
* 好动的人
    * 优点：社交牛逼症
    * 缺点：沉下心来搞研究难
* 喜静的人
    * 优点：能沉下心来琢磨事情
    * 缺点：社交困难
做一个动静结合的人？既能沉下来搞研究，也能出去处理人际关系

# 关于加班

* 有意义、有价值和能成长的忙碌不会让人产生真正疲惫，反而是不断焕发新的激情；
* 在错误的方向，复杂的人事上内耗会让人心力交瘁，即便准点下班也会心理疲惫；

# 关于中间层

一段话：所有的问题都能通过加一层中间层解决，如果不行，那就再加一层；

中间层的好处是屏蔽细节，简化API，增大通用性，但是以损失性能为代价
## 编程世界

例子：
* [N-API](https://blog.poetries.top/node-learning-notes/notes/advance/-node8_napi.html#n-api%E7%AE%80%E4%BB%8B)解决Node addon跟V8 API强绑定导致的升级困难；猜想大概率是做了一个 开发 Node Addon的通用API规范（底层可能还是通过封装V8实现，但是开发者不需要关心具体的V8 API是啥）
* Taro3 能做到框架独立（同时支持react/vue等框架语法），也是在编译中间加了一层编译IR，然后把IR再转换成对应的目标代码
* React 能做到编写 APP，也是在代码编译中加了一层虚拟DOM中间层 IR（如果是直接编译到浏览器Dom就没跨端什么事了），可以进行不同平台的适配
* LLVM 做成了标准的编译中间层IR，方便无数的新生语言（eg：Rust）可以以 LLVM 作为目标来编译，而无需去适配不同的操作系统
* JsBridge原理连接了js世界跟Native世界，丰富了js的可能性，代价是JsBridge沟通的性能损失
...

## 生活世界

* 如果一件事情处理不了，那就找人帮忙，如果还不行，那就再找一个人？
* 各种网络平台也就是把自己做成一个中间层，方便人事的协同？

# 关于补救方案

事物无时无刻都在向前发展，很多发展中的问题都是不可预测，所以基本没有一开始就设计出的完美的方案，于是补救方案就来了；当前的补救方案可能促进方案的成长

## 编程

* 当开发者跟Rust语言对Safe的场景认同不一致的时候，Rust决定把选择权交给开发，于是有了Unsafe；如果开发者正确，那可能是Rust进化的不错机会；例如：extern关键字协助创建外部函数接口（Foreign Function Interface， FFI），extern的函数就肯定是Unsafe的，因为rust没法进行静态检测其他语言的
* 当开发者跟typescript对lint的场景认同不一致的时候，于是有了 "//@ts-ignore"；可能是TS进化的机会

## 人类

* 认知的补救方案，早期人类遇到无法解释的现象首先是发挥想象力，创造一个万能的神明；
* 关于个人无法化解的场景，可能通过笑来化解；所以笑是避免大脑死机的补救方案？

# 关于趋势

事物的发展都有一定的规律，把握了正确规律可以事半功倍

## 计算机相关

* 语言的发展：更快、更安全、更容易掌握、特定问题的更好解决方案
    * Rust就是比C++更友好更安全的方向
    * Go 就是来提供更好的服务并发方案



# 关于js原型链

## 有意思的现象

```js
function A(name){
    this.name = name
}

Function.prototype.age = 1

let a = new A('a') // a是一个非函数的对象了

console.log(a.age); // undefined；原因：a.__proto__ === A.prototype ，A.prototype.__proto === Object.prototype

console.log(A.call); // 有值；原因：A.__proto__ === Function.prototype


```

# 关于GC

## 手动
方式：new/delete等手动方式
语言：C++等
优点：灵活
缺点：忘记或者回收不当会导致内存泄漏风险

## 自动 
* 方式：引用计数，标记清扫，节点复制，新老生代转化组合等；周期性的暂停程序执行而进行GC工作
* 典型的语言：js，go
* 优点：编写简单
* 缺点：GC频繁会导致程序执行性能受到影响

## 无GC
* 方式：所有权
* 语言：Rust
* 优点：性能高，安全
* 缺点：学习曲线陡峭
* 思考：实际有GC，只是效率高到不会妨碍到现有程序执行？

摘要
>Rust would know when the variable gets out of scope or its lifetime ends at compile time and thus insert the corresponding LLVM/assembly instructions to free the memory.

## Reference
* [what-does-rust-have-instead-of-a-garbage-collector](https://stackoverflow.com/questions/32677420/what-does-rust-have-instead-of-a-garbage-collector?noredirect=1&lq=1)

# React 踩坑之路由动画
例子：react-router-dom 从版本 6 开始就废弃了Switch组件，用Routes做了替换，然而使用上跟Switch有差别？第三方库 react-router-transition 目前依赖peerDependency react-router-dom@5，也就是升级react-router-dom直接崩？又因为breaking change的差异大，导致 react-router-transition 没法简单就能跟随升级
相关文档：[[Feature]: Compatibility layer that implements the v5 API ](https://github.com/remix-run/react-router/issues/8695)

* 现状：现在找个解决方案费时费力，各种实践层出不穷，核心库的breaking change没经过周全的思考就去实施，然后就是一堆填坑的工作量；
* 建议：React能否学习Vue把最佳实践维护起来，优势：可以做更周全稳定迭代，方便开发者找到最佳实践，提升工作效率；劣势：是啥？



***个人拙见，酌情观看***


# 关于认知

越来越感觉到认知能力才是事情发展的关键，认知是基础然后才是生成要素的聚集；太聚焦在解决问题层面，陷入到具体实现细节的可能不是一个好的开发

**认知的排序以及问题的解决流程**

1. 发现问题
2. 定义问题
3. 分解问题
4. 问题排序
5. 解决问题（可能是大部分人停留的阶段）

基层干部需要**分解问题**能力，然后是其他生产要素的收集（安排优先级，找到合适的人，定一个完成时间等）

重要核心岗位需要**发现问题**的能力，比起知道如何做，更需要找到值得去做的事情（方向不对，努力白费），然后才是技术介入，定义问题解决问题

关于认知的例子:

流媒体：看下netflix跟国内的爱优腾的区别，前者自研内容飞涨带着股价飞涨，后者还在天价争夺版权，亏损到现在，爱奇艺最近（2021年底）大裁员了

技术界：前端大神Evanyou，产出了Vue，之后又诞生了vite，能在合适的时机出手带领一波技术潮流；除了技术强，核心可能在于领先同行的认知水平

# 关于沟通
1. 首先得把概念澄清
    * 划分概念边界（定义解决的问题类型，例如：vue-cli plugin可以定义成面向工程结构的开发；解释webpack plugin则是面向源码的转换开发）
    * 类比熟悉概念（例如：解释 vue-cli的plugin机制，就可以类比 webpack plugin机制）

# 关于自举
编程里面有个概念叫：自举；
>编程语言自己编译自己，重复这个过程可以让本身进化
>>例如：辅助增添新的语言特征，新的特征必须要能用旧的版本来编译解析，也叫向后兼容；
>>理论上编程语言可以通过自举来完成自身进化，不过更多只是体现在已有概念重组跟语法糖上，没法在底层上做大的改进

>rust的出现的其中一个原因就是为了摒弃语言的历史包袱，实现一个真正意义的高级语言

学习知识的过程也可以理解成“自举”
>通过自身已知概念来解释新知识，将新知识逐步建立在旧知识体系之上，从而“学习到”新知识
>>例如：小学算术是从简单1+1=2，再用个位解释灌输十位，用十位解释百位...再例如：学习编程，有C++基础学js语言会比有js基础再学C++简单

在变化中寻找自举的底层动力，不要怕吭硬骨头，了解底层编程模型范式更能增加自举进化可能性

# 关于动静结合

## 编程语言层面
* 动态语言（JIT+VM动态编译执行，例如js）；
    * 优点：动态下发，容易做热替换，热更新等；dev体验好
    * 缺点：production性能较差

* 静态语言（AOT编译成二进制+Runtime，例如C）
    * 优点：production性能较好
    * 缺点：无法动态下发，没法热替换，dev需要等待编译完成

flutter选在dart语言（动静结合）,dev下JIT，production阶段AOT；兼顾dev跟production

## 性格
* 好动的人
    * 优点：社交牛逼症
    * 缺点：沉下心来搞研究难
* 喜静的人
    * 优点：能沉下心来琢磨事情
    * 缺点：社交困难
做一个动静结合的人？既能沉下来搞研究，也能出去处理人际关系

# 关于加班

* 有意义、有价值和能成长的忙碌不会让人产生真正疲惫，反而是不断焕发新的激情；
* 在错误的方向，复杂的人事上内耗会让人心力交瘁，即便准点下班也会心理疲惫；

# 关于提纲挈领

提纲挈领：比喻善于抓住问题的关键与要害；

## 前端

抓住核心所在可以事半功倍，更容易理解一个事物；比如：
1. 月经问题，Vue跟React的区别？核心在于Immutable跟Mutable这个理念，其他很多都是在此上的衍生问题
2. Webpack跟Vite区别？核心在真正按需的理念
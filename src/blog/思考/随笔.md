# 文章精读之设计原则/模式
## 设计原则：SOLID原则
* Single Responsibility Principle 单一原则；
    - 一种Class只负责一类事情
* Open/Closed Principle 开闭原则；
    - 允许在不改变已有代码前提下添加新功能
* Liskov Substitution Principle 里氏替换原则；
    - 不要从可实例化的父类中继承（方法），而是要使用基于抽象类和接口的继承。
* Interface Segregation Principle 接口隔离原则；
    - Clients should not be forced to depend upon interfaces that they do not use. 对于非必须的参数做可选配置，精简接口，简化使用
* Dependency Inversion Principle 依赖反转原则
    - High-level modules should not depend on low-level modules. 
    - Both should depend on abstractions.Abstractions should not depend upon details. Details should depend on abstractions.
    - 降低耦合，方便重构跟扩展
## 设计模式
### Creational Patterns
* Fatory Method
* SingleTon
### Behavioral Patterns
* Strategy
* Observer
* Iterator
### Structural Patterns
* Adapter
* Decorator
* Proxy
## 设计原则 vs 设计模式
* 简洁理解：设计模式（语言相关）是对设计原则（语言独立）的实现
* 长文理解
    - Design principles provide high level guidelines to design better software applications. They do not provide implementation guidelines and are not bound to any programming language.
    - Design Pattern provides low-level solutions related to implementation, of commonly occurring object-oriented problems. In other words, design pattern suggests a specific implementation for the specific object-oriented programming problem.

## Reference
* https://github.com/ryanmcdermott/clean-code-javascript#solid
* https://www.tutorialsteacher.com/articles/difference-between-design-principle-and-design-pattern
* https://github.com/sohamkamani/javascript-design-patterns-for-humans#behavioral-design-patterns
* https://github.com/lpxxn/rust-design-pattern

# 关于继承
谈到继承就会说到“类”，“类”封装的是数据，是对同一类数据实体以及其处理方法的抽象。

* 目的：
    1. 代码复用
    2. 多态（同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。实现方式：覆盖，重载；某种程度也算代码复用？）
        * 覆盖：指子类重新定义父类方法，例如js的prototype
        * 重载：多个同名但参数不同的方法，例如 Rust 函数模板

* 继承方式：
    1. 正统：C++,java
    2. 模拟：js原型链
    3. 无：Rust trait 组合实现多态
        思考：Rust 的编程建模模式更像是组合（Composition） 而不是继承（Inheritance）？有点类似 Vue3 选择 Composition-API 代替 Class-Option？

多态图解：![多态](https://pic1.zhimg.com/80/v2-6f26625afb5174fa5228e817cd68a7db_1440w.jpg?source=1940ef5c)

[图来源](https://www.zhihu.com/question/66038192/answer/1898435232)
### Reference
* [为什么Rust没有继承？](https://fengliang.io/RustWHY/design_choices/why_not_inheritance.html)
* https://www.runoob.com/rust/rust-object.html

# 关于面向对象

* 解释：面向对象的编程语言通常实现了数据的封装与继承并能基于数据调用方法。
* 有：js一切都是对象
* 无：Rust 不是面向对象的编程语言，但这些功能都得以实现。

# React状态管理

* Redux
    * 通过props注入 dispatch/state，规避了 useContext 方案可能导致的重复渲染
* Mobx （有点类似createContext + useContext + reactivity）
    * 特征：Mobx + React 类似等于 Vue
* createContext + useContext + useReducer
    * 坑：createContext 返回的 Provider 中 value变化会触发所有子组件重复渲染
        * 关联思考：这种方案适用于小型的状态管理？
    * Todo：了解重复渲染的运转机制
    * 优化：对渲染做 useMemo
# 文章精读之前端框架设计
## 组件类型
    
* 纯展示型的组件，数据进，DOM出，直观明了
* 接入型组件，在React场景下的container component，这种组件会跟数据层的service打交道，会包含一些跟服务器或者说数据源打交道的逻辑，container会把数据向下*传递给展示型组件
* 交互型组件，典型的例子是对于表单组件的封装和加强，大部分的组件库都是以交互型组件为主，比如说Element UI，特点是有比较复杂的交互逻辑，但是是比较通用的逻辑，强调组件的复用
* 功能型组件，以Vue的应用场景举例，路由的router-view组件、transition组件，本身并不渲染任何内容，是一个逻辑型的东西，作为一种扩展或者是抽象机制存在

## 状态管理
如何管理将事件源映射到状态变化的过程，如何将这个映射的过程从视图组件中剥离出来，如何组织这一部分代码来提高可维护性，是状态管理要解决的本质问题
## CSS方案
* css modules
* css-in-js
## 构建工具
解决的问题
* 任务的自动化
* 开发体验和效率（新的语言功能，语法糖，hot reload 等等）
* 部署相关的需求
* 编译时优化
## Reference
* [Evanyou 聊聊前端框架](https://juejin.cn/post/6844903510455107598)

# CSS Animation,Transition 原理
* GPU比较擅长于：

    - 绘制位图到屏幕

    - 重复的绘制同一个位图

    - 在不同的位置，以不同的旋转角度，或者不同的缩放大小来绘制同一个位图。

* GPU相对慢的地方：

    - 将位图加载到显存里。

例子：
```css
/*hover的时候height变化 100 -> 200的过程中重复计算元素当前位图然后回传给GPU绘制*/
div {   
    height: 100px;   
    transition: height 1s linear;   
}   

div:hover {   
    height: 200px;   
} 

/*
CSS的transform属性不会改变元素的布局，也不会影响到其周围的元素。它把元素当做一个整体看待——缩放整个元素、旋转整个元素或者移动整个元素。
所以位图只会在cpu跟GPU 之间传递一次，scale的重新绘制只发生在GPU，而不会阻塞主线程，也就是更加流畅？
*/
div {   
    transform: scale(0.5);   
    transition: transform 1s linear;   
}   
     
div:hover {   
    transform: scale(1.0);   
}  
```
## 总结
选择独立性比较强的CSS属性有助于改善动画效果：transform，opacity，filter （依赖于过滤器的复杂度和浏览器）

拓展：渲染线程分为 主线程 (main thread) 和 合成线程 (compositor thread)
## Reference
* https://www.jb51.net/css/348357.html

# Vue运行时错误处理
Vue源码里面lifeCycle/watch/directive/transition等的callback/hook等一般会被封装执行
```js
 const res = callWithAsyncErrorHandling(hook, target, type, args)
 ```
* 封装执行要素：  
    - fn: Function,
    - instance: ComponentInternalInstance | null,
    - type: ErrorTypes,
* 错误分类：LifecycleHooks | ErrorCodes（其他函数执行点：callback + hook等）
* 同步错误处理：尝试函数运行处理同步错误，并搜集返回值
* 异步错误处理：根据返回值是否Promise来处理异步错误
## Reference

* [@vue/runtime-core/errorHandling](https://github.com/vuejs/core/blob/main/packages/runtime-core/src/errorHandling.ts)

# 插件对比（Vue vs React）

## 插件
1. Vue插件
```js
// calls `MyPlugin.install(Vue)`
Vue.use(MyPlugin)

new Vue({
  //... options
})
/**
 * 
 * 适配 Vue3的 Composition-API场景
 * 1. 在MyPlugin初始化阶段 app.provide(injectKey)注入实例
 * 2. 在MyPlugin use阶段 app.inject(injectKey)获取实例
 * 
 * Class 场景
 * 1. 初始化阶段 把 MyPlugin 逐步 mixin 到子组件
 * 2. 调用阶段直接在组件实例上获取
```
2. React插件
```js
// 例子
 <Provider store={store}>
 </Provider>
 ```
 // 使用地方：一般需要对组件做二次封装进行connect，然后可以useDispatch，**类似Vue inject？**
### 插件的插件（Vuex vs Redux）
1. Vuex插件
```js
// 插件模板
const myPlugin = (store) => {
  // called when the store is initialized
  store.subscribe((mutation, state) => {
    // called after every mutation.
    // The mutation comes in the format of `{ type, payload }`.
  })
}
```
```js
// 插件使用
const store = createStore({
  // ...
  plugins: [myPlugin]
})
```
// 插件案例
[vuex-persistedstate](https://github.com/robinvdvleuten/vuex-persistedstate)通过对mutation的拦截，对模块paths进行精准持久化

2. Redux 中间件
```js
// 插件例子
const logger = store => next => action => {
  console.log('dispatching', action)
  let result = next(action)
  console.log('next state', store.getState())
  return result
}
```
```js
// 插件使用
import { createStore, combineReducers, applyMiddleware } from 'redux'

const todoApp = combineReducers(reducers)
const store = createStore(
  todoApp,
  // applyMiddleware() tells createStore() how to handle middleware
  applyMiddleware(logger, crashReporter)
)

```
// 复杂案例
[redux-persist](https://github.com/rt2zz/redux-persist#nested-persists)

## 总结
Vue的mutable 比 React的immutable对数据的状态的操作来的直接，导致在状态处理插件模式也会不同；vuex（直接mutation改变数据）整体上比redux（通过dispatch action，走整个reducer流程返回新的state）更加直接，导致插件模式上vuex直接劫持mutation比redux劫持reducer来的更加简单
## Reference
* https://vuex.vuejs.org/guide/plugins.html
* https://redux.js.org/understanding/history-and-design/middleware
* https://v2.vuejs.org/v2/guide/plugins.html?redirect=true

# 模拟LRU的数据结构（Set vs Array）
Set会自动追踪插入的先后顺序

1. Set结构
```js
let s = new Set()

s.add(3)
s.add(2)

// make this key the freshest
s.delete(3)
s.add(3)

// get Oldest
console.log(s.values().next().value); //2
```

2. Array结构
```js
let s = []

s.push(2)
s.push(3)

// make this key the freshest
s.splice(s.indexOf(3))
s.push(3)

// get Oldest
console.log(s[0])
```
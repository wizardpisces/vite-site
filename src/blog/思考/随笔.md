## 关于继承
谈到继承就会说到“类”，“类”封装的是数据，是对同一类数据实体以及其处理方法的抽象。

* 目的：
    1. 代码复用
    2. 多态（同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。实现方式：覆盖，重载；某种程度也算代码复用？）
        * 覆盖：指子类重新定义父类方法，例如js的prototype
        * 重载：多个同名但参数不同的方法，例如 Rust 函数模板

* 继承方式：
    1. 正统：C++,java
    2. 模拟：js原型链
    3. 无：Rust trait 组合实现多态
        思考：Rust 的编程建模模式更像是组合（Composition） 而不是继承（Inheritance）？有点类似 Vue3 选择 Composition-API 代替 Class-Option？

一张有意思多态图：![多态](https://pic1.zhimg.com/80/v2-6f26625afb5174fa5228e817cd68a7db_1440w.jpg?source=1940ef5c)

[图来源](https://www.zhihu.com/question/66038192/answer/1898435232)
### Reference
* [为什么Rust没有继承？](https://fengliang.io/RustWHY/design_choices/why_not_inheritance.html)
* https://www.runoob.com/rust/rust-object.html

## 关于面向对象

* 解释：面向对象的编程语言通常实现了数据的封装与继承并能基于数据调用方法。
* 有：js一切都是对象
* 无：Rust 不是面向对象的编程语言，但这些功能都得以实现。

## React状态管理

* Redux
    * 通过props注入 dispatch/state，规避了 useContext 方案可能导致的重复渲染
* Mobx （有点类似createContext + useContext + reactivity）
    * 特征：Mobx + React 类似等于 Vue
* createContext + useContext + useReducer
    * 坑：createContext 返回的 Provider 中 value变化会触发所有子组件重复渲染
        * 关联思考：这种方案适用于小型的状态管理？
    * Todo：了解重复渲染的运转机制
    * 优化：对渲染做 useMemo

调研：
* swr.js + useContext
* reapex

## 文章精读摘录

### 组件类型
    
* 纯展示型的组件，数据进，DOM出，直观明了
* 接入型组件，在React场景下的container component，这种组件会跟数据层的service打交道，会包含一些跟服务器或者说数据源打交道的逻辑，container会把数据向下*传递给展示型组件
* 交互型组件，典型的例子是对于表单组件的封装和加强，大部分的组件库都是以交互型组件为主，比如说Element UI，特点是有比较复杂的交互逻辑，但是是比较通用的逻辑，强调组件的复用
* 功能型组件，以Vue的应用场景举例，路由的router-view组件、transition组件，本身并不渲染任何内容，是一个逻辑型的东西，作为一种扩展或者是抽象机制存在

### 状态管理
如何管理将事件源映射到状态变化的过程，如何将这个映射的过程从视图组件中剥离出来，如何组织这一部分代码来提高可维护性，是状态管理要解决的本质问题
### CSS方案
* css modules
* css-in-js
### 构建工具
解决的问题
* 任务的自动化
* 开发体验和效率（新的语言功能，语法糖，hot reload 等等）
* 部署相关的需求
* 编译时优化
### Reference
* [Evanyou 聊聊前端框架](https://juejin.cn/post/6844903510455107598)
# Docker 镜像

## 层次关系

Docker 镜像的层次关系原理基于联合文件系统（Union File System），这种文件系统允许多个文件系统层次叠加在一起，表现为一个单一的文件系统。Docker 利用这一特性来构建和管理镜像和容器。

### 联合文件系统（Union File System）

联合文件系统（如 AUFS、OverlayFS、btrfs 等）是 Docker 的核心技术之一。它允许多个目录（称为层）叠加在一起，使其看起来像一个单一的目录。每一层都是只读的，只有最顶层是可写的。

### Docker 镜像层次结构

Docker 镜像由多个只读层组成，每一层对应 Dockerfile 中的一条指令。这些层是增量的，即每一层只包含相对于前一层的变化。镜像层次结构的基本原理如下：

1. **基础镜像层**：这是镜像的最底层，通常是一个操作系统的基础镜像（如 `ubuntu`、`alpine`、`node` 等）。它提供了运行应用所需的基本环境。

2. **中间层**：每一条 Dockerfile 指令（如 `RUN`、`COPY`、`ADD` 等）都会创建一个新的层。每个中间层只包含相对于前一层的变化。例如，安装软件包、复制文件等。

3. **顶层**：这是镜像的最顶层，通常包含应用程序的代码和配置文件。

### 容器层次结构

当你启动一个容器时，Docker 会在镜像的基础上添加一个可写层，这个可写层称为容器层。容器层是唯一可写的层，所有对文件系统的修改（如创建新文件、修改现有文件等）都会发生在这一层。

### 分层存储的优点

1. **高效存储**：由于每一层是只读的，并且是增量的，Docker 可以通过共享相同的基础层来节省存储空间。例如，多个基于同一基础镜像的容器可以共享该基础镜像的层。

2. **快速构建**：构建镜像时，如果某一层已经存在且没有变化，Docker 可以直接重用该层，而不需要重新构建。这大大加快了镜像的构建速度。

3. **缓存机制**：Docker 使用缓存机制来加速镜像的构建和部署。如果某一层已经存在于缓存中，并且没有变化，Docker 可以直接从缓存中获取该层，而不需要重新执行指令。

### 示例：Docker 镜像和容器的层次关系

假设我们有如下的 Dockerfile：

```Dockerfile
# 使用官方的 Node.js 镜像作为基础镜像
FROM node:14

# 设置工作目录
WORKDIR /app

# 复制 package.json 和 package-lock.json 到工作目录
COPY package*.json ./

# 安装依赖
RUN npm install

# 复制应用程序代码到工作目录
COPY . .

# 暴露应用程序运行的端口
EXPOSE 3000

# 运行应用程序
CMD ["node", "app.js"]
```

构建镜像时，每一条指令都会创建一个新的层：

1. **基础镜像层**：`FROM node:14`
2. **工作目录层**：`WORKDIR /app`
3. **复制依赖文件层**：`COPY package*.json ./`
4. **安装依赖层**：`RUN npm install`
5. **复制应用程序代码层**：`COPY . .`
6. **暴露端口层**：`EXPOSE 3000`
7. **运行应用程序层**：`CMD ["node", "app.js"]`

当你运行容器时，Docker 会在这些只读层的基础上添加一个可写层。所有对文件系统的修改都会发生在这个可写层中。

### 联合文件系统（Union File System）

联合文件系统（Union File System）如何允许多个文件系统层次叠加在一起，表现为一个单一的文件系统。例子：

假设我们有三个不同的目录，每个目录代表一个文件系统层：

1. **Layer 1**：包含基本的操作系统文件
2. **Layer 2**：包含一些应用程序文件
3. **Layer 3**：包含用户的数据文件，容器运行时的**可写层**

#### 目录结构

- **Layer 1**（基础操作系统层）
  ```
  /bin
  /lib
  /etc
  ```

- **Layer 2**（应用程序层）
  ```
  /app
  /usr/local/bin
  ```

- **Layer 3**（用户数据层）
  ```
  /home/user
  /var/log
  ```

#### 叠加后的联合文件系统

当我们使用联合文件系统将这三个层叠加在一起时，它们会表现为一个单一的文件系统：

```
/bin
/lib
/etc
/app
/usr/local/bin
/home/user
/var/log
```

### 具体例子：Docker 镜像和容器

让我们将这个概念应用到 Docker 镜像和容器上：

1. **基础镜像（Layer 1）**：假设我们使用一个 Ubuntu 基础镜像，它包含了操作系统的基本文件。
   ```
   /bin
   /lib
   /etc
   ```

2. **应用程序层（Layer 2）**：我们在基础镜像上安装了一个应用程序，这会创建一个新的层。
   ```
   /app
   /usr/local/bin
   ```

3. **用户数据层（Layer 3）**：容器运行时，用户在容器内创建或修改文件，这些变化会记录在一个可写层中。
   ```
   /home/user
   /var/log
   ```

#### 叠加后的文件系统

当我们启动容器时，Docker 会将这些层叠加在一起，表现为一个单一的文件系统：

```
/bin
/lib
/etc
/app
/usr/local/bin
/home/user
/var/log
```

用户在容器内看到的文件系统就像是一个完整的文件系统，尽管它实际上是由多个层叠加而成的。

### 总结

联合文件系统的关键在于它能够将多个只读层（代表不同的文件系统状态）和一个可写层（用于记录运行时的变化）叠加在一起，使用户看到的文件系统表现为一个单一的整体。这种机制在 Docker 中被广泛应用，用于高效地管理和共享镜像层，从而实现快速的容器启动和高效的存储利用。